"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is = exports.assert = exports.Shape = exports.withMetadata = exports.createShape = void 0;
const assert_js_1 = require("./assert.js");
const buffer_js_1 = require("./buffer.js");
const util_js_1 = require("./util.js");
function createShape(_shape) {
    const { staticSize, subEncode, subAssert, subDecode, metadata } = _shape;
    const shape = {
        // @ts-ignore https://gist.github.com/tjjfvi/ea194c4fce76dacdd60a0943256332aa
        __proto__: Shape.prototype,
        staticSize,
        subEncode,
        subDecode,
        subAssert,
        metadata,
    };
    return shape;
}
exports.createShape = createShape;
function withMetadata(metadata, shape) {
    const result = {
        // @ts-ignore https://gist.github.com/tjjfvi/ea194c4fce76dacdd60a0943256332aa
        __proto__: Shape.prototype,
        ...shape,
        metadata: [...metadata, ...shape.metadata],
    };
    return result;
}
exports.withMetadata = withMetadata;
const shapeInspectCtx = new Map();
let shapeInspectIdN = 0;
const nodeCustomInspect = Symbol.for("nodejs.util.inspect.custom");
const denoCustomInspect = Symbol.for("Deno.customInspect");
class _Shape {
    [nodeCustomInspect](_0, _1, inspect) {
        return this._inspect(inspect);
    }
    [denoCustomInspect](inspect, opts) {
        return this._inspect((x) => inspect(x, opts));
    }
    _inspect(inspect) {
        let id = shapeInspectCtx.get(this);
        if (id !== undefined) {
            if (id === null) {
                shapeInspectCtx.set(this, id = shapeInspectIdN++);
            }
            return `$${id}`;
        }
        try {
            shapeInspectCtx.set(this, null);
            const metadata = this.metadata[0];
            const content = metadata
                ? metadata.type === "atomic"
                    ? metadata.name
                    : `${metadata.name}(${inspect(metadata.args).replace(/^\[(?: (.+) |(.+))\]$/s, "$1$2")})`
                : "?";
            id = shapeInspectCtx.get(this);
            return id !== null ? `$${id} = ${content}` : content;
        }
        finally {
            shapeInspectCtx.delete(this);
            if (shapeInspectCtx.size === 0)
                shapeInspectIdN = 0;
        }
    }
}
class Shape extends _Shape {
    /** Encodes the value into a new Uint8Array (throws if async) */
    encode(value) {
        const buf = new buffer_js_1.EncodeBuffer(this.staticSize);
        this.subEncode(buf, value);
        if (buf.asyncCount)
            throw new util_js_1.ShapeEncodeError(this, value, "Attempted to synchronously encode an async shape");
        return buf.finish();
    }
    /** Asynchronously encodes the value into a new Uint8Array */
    async encodeAsync(value) {
        const buf = new buffer_js_1.EncodeBuffer(this.staticSize);
        this.subEncode(buf, value);
        return buf.finishAsync();
    }
    /** Decodes a value from the supplied Uint8Array */
    decode(array) {
        const buf = new buffer_js_1.DecodeBuffer(array);
        return this.subDecode(buf);
    }
    /** Requires the shape to have an explicit type annotation; if it doesn't, use `$.assert` instead. */
    assert(value) {
        assert(this, value);
    }
}
exports.Shape = Shape;
/** Asserts that the value is valid for the specified shape */
function assert(shape, value) {
    shape.subAssert(new assert_js_1.AssertState(value));
}
exports.assert = assert;
function is(shape, value) {
    try {
        shape.subAssert(new assert_js_1.AssertState(value));
        return true;
    }
    catch (e) {
        if (e instanceof util_js_1.ShapeAssertError) {
            return false;
        }
        else {
            throw e;
        }
    }
}
exports.is = is;
//# sourceMappingURL=shape.js.map