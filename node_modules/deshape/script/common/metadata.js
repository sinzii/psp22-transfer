"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ShapeVisitor_fallback, _ShapeVisitor_visitors;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeVisitor = exports.metadata = void 0;
const shape_js_1 = require("./shape.js");
function metadata(...fullArgs) {
    if (typeof fullArgs[0] !== "string")
        return fullArgs.flat();
    const [name, factory, ...args] = fullArgs;
    return [
        factory
            ? {
                type: "factory",
                name,
                factory,
                args,
            }
            : {
                type: "atomic",
                name,
            },
    ];
}
exports.metadata = metadata;
class ShapeVisitor {
    constructor() {
        _ShapeVisitor_fallback.set(this, void 0);
        _ShapeVisitor_visitors.set(this, new Map());
    }
    add(shape, fn) {
        if (shape instanceof shape_js_1.Shape) {
            shape = shape.metadata[0];
            if (!shape)
                throw new Error("Cannot register visitor for metadata-less shape");
        }
        if (__classPrivateFieldGet(this, _ShapeVisitor_visitors, "f").has(shape)) {
            throw new Error("Duplicate visitor");
        }
        __classPrivateFieldGet(this, _ShapeVisitor_visitors, "f").set(shape, fn);
        return this;
    }
    fallback(fn) {
        if (__classPrivateFieldGet(this, _ShapeVisitor_fallback, "f")) {
            throw new Error("Duplicate fallback");
        }
        __classPrivateFieldSet(this, _ShapeVisitor_fallback, fn, "f");
        return this;
    }
    /**
     * ```ts
     * visitor.generic(<T>() =>
     *   visitor.add($.array<T>, (shape, $el) => {
     *     ...
     *   })
     * )
     * ```
     */
    generic(fn) {
        fn(this);
        return this;
    }
    visit(shape) {
        for (const metadata of shape.metadata) {
            let visitor = __classPrivateFieldGet(this, _ShapeVisitor_visitors, "f").get(metadata);
            if (visitor)
                return visitor(shape);
            if (metadata.type !== "factory")
                continue;
            visitor = __classPrivateFieldGet(this, _ShapeVisitor_visitors, "f").get(metadata.factory);
            if (visitor)
                return visitor(shape, ...metadata.args);
        }
        if (__classPrivateFieldGet(this, _ShapeVisitor_fallback, "f")) {
            return __classPrivateFieldGet(this, _ShapeVisitor_fallback, "f").call(this, shape);
        }
        throw new Error("Unrecognized shape");
    }
}
exports.ShapeVisitor = ShapeVisitor;
_ShapeVisitor_fallback = new WeakMap(), _ShapeVisitor_visitors = new WeakMap();
//# sourceMappingURL=metadata.js.map