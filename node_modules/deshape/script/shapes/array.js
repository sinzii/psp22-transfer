"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sizedUint8Array = exports.uint8Array = exports.array = exports.sizedArray = void 0;
const mod_js_1 = require("../common/mod.js");
const compact_js_1 = require("./compact.js");
const int_js_1 = require("./int.js");
const compactU32 = (0, compact_js_1.compact)(int_js_1.u32);
function sizedArray($el, length) {
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.sizedArray", sizedArray, $el, length),
        staticSize: $el.staticSize * length,
        subEncode(buffer, value) {
            for (let i = 0; i < value.length; i++) {
                $el.subEncode(buffer, value[i]);
            }
        },
        subDecode(buffer) {
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el.subDecode(buffer);
            }
            return value;
        },
        subAssert(assert) {
            assert.instanceof(this, Array);
            assert.key(this, "length").equals(this, length);
            for (let i = 0; i < length; i++) {
                $el.subAssert(assert.key(this, i));
            }
        },
    });
}
exports.sizedArray = sizedArray;
function array($el) {
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.array", array, $el),
        staticSize: compactU32.staticSize,
        subEncode(buffer, value) {
            compactU32.subEncode(buffer, value.length);
            if (value.length) {
                buffer.pushAlloc(value.length * $el.staticSize);
                for (let i = 0; i < value.length; i++) {
                    $el.subEncode(buffer, value[i]);
                }
                buffer.popAlloc();
            }
        },
        subDecode(buffer) {
            const length = compactU32.subDecode(buffer);
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el.subDecode(buffer);
            }
            return value;
        },
        subAssert(assert) {
            assert.instanceof(this, Array);
            for (let i = 0; i < assert.value.length; i++) {
                $el.subAssert(assert.key(this, i));
            }
        },
    });
}
exports.array = array;
exports.uint8Array = (0, mod_js_1.createShape)({
    metadata: (0, mod_js_1.metadata)("$.uint8Array"),
    staticSize: compactU32.staticSize,
    subEncode(buffer, value) {
        compactU32.subEncode(buffer, value.length);
        buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
    },
    subDecode(buffer) {
        const length = compactU32.subDecode(buffer);
        const value = buffer.array.subarray(buffer.index, buffer.index + length);
        buffer.index += length;
        return value;
    },
    subAssert(assert) {
        assert.instanceof(this, Uint8Array);
    },
});
function sizedUint8Array(length) {
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.sizedUint8Array", sizedUint8Array, length),
        // We could set `staticSize` to `length`, but in this case it will usually
        // more efficient to insert the array dynamically, rather than manually copy
        // the bytes.
        staticSize: 0,
        subEncode(buffer, value) {
            buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
        },
        subDecode(buffer) {
            return buffer.array.subarray(buffer.index, buffer.index += length);
        },
        subAssert(assert) {
            assert.instanceof(this, Uint8Array);
            assert.key(this, "length").equals(this, length);
        },
    });
}
exports.sizedUint8Array = sizedUint8Array;
//# sourceMappingURL=array.js.map