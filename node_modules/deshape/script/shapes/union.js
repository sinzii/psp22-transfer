"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.literalUnion = exports.taggedUnion = exports.variant = exports.Variant = void 0;
const mod_js_1 = require("../common/mod.js");
const constant_js_1 = require("./constant.js");
const object_js_1 = require("./object.js");
class Variant {
    constructor(tag, shape) {
        Object.defineProperty(this, "tag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: tag
        });
        Object.defineProperty(this, "shape", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: shape
        });
    }
}
exports.Variant = Variant;
function variant(tag, ...members) {
    return new Variant(tag, (0, object_js_1.object)(...members));
}
exports.variant = variant;
function taggedUnion(tagKey, members) {
    const tagToDiscriminant = Object.create(null);
    const discriminantToMember = Object.create(null);
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const { tag, shape } = members[discriminant];
        tagToDiscriminant[tag] = discriminant;
        discriminantToMember[discriminant] = (0, object_js_1.object)((0, object_js_1.field)(tagKey, (0, constant_js_1.constant)(tag)), shape);
    }
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.taggedUnion", taggedUnion, tagKey, members),
        staticSize: 1 + Math.max(...Object.values(discriminantToMember).map((x) => x.staticSize)),
        subEncode(buffer, value) {
            const discriminant = tagToDiscriminant[value[tagKey]];
            const $member = discriminantToMember[discriminant];
            buffer.array[buffer.index++] = discriminant;
            $member.subEncode(buffer, value);
        },
        subDecode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            const $member = discriminantToMember[discriminant];
            if (!$member) {
                throw new mod_js_1.ShapeDecodeError(this, buffer, `No such member shape matching the discriminant \`${discriminant}\``);
            }
            return $member.subDecode(buffer);
        },
        subAssert(assert) {
            const assertTag = assert.key(this, tagKey);
            assertTag.typeof(this, "string");
            if (!(assertTag.value in tagToDiscriminant)) {
                throw new mod_js_1.ShapeAssertError(this, assertTag.value, `${assertTag.path}: invalid tag`);
            }
            discriminantToMember[tagToDiscriminant[assertTag.value]].subAssert(assert);
        },
    });
}
exports.taggedUnion = taggedUnion;
function literalUnion(members) {
    const keyToDiscriminant = new Map();
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const key = members[discriminant];
        keyToDiscriminant.set(key, discriminant);
    }
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.literalUnion", literalUnion, members),
        staticSize: 1,
        subEncode(buffer, value) {
            const discriminant = keyToDiscriminant.get(value);
            buffer.array[buffer.index++] = discriminant;
        },
        subDecode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            return members[discriminant];
        },
        subAssert(assert) {
            assert.typeof(this, "string");
            if (!keyToDiscriminant.has(assert.value)) {
                throw new mod_js_1.ShapeAssertError(this, assert.value, `${assert.path} invalid value`);
            }
        },
    });
}
exports.literalUnion = literalUnion;
//# sourceMappingURL=union.js.map