"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.int = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;
const mod_js_1 = require("../common/mod.js");
exports.u8 = (0, mod_js_1.createShape)({
    metadata: intMetadata(false, 8),
    staticSize: 1,
    subEncode(buffer, value) {
        buffer.array[buffer.index++] = value;
    },
    subDecode(buffer) {
        return buffer.array[buffer.index++];
    },
    subAssert(assert) {
        assert.integer(this, 0, 255);
    },
});
function _intNumber(signed, size) {
    const byteSize = size / 8;
    const key = `${(signed ? "Int" : "Uint")}${size}`;
    const getMethod = DataView.prototype[`get${key}`];
    const setMethod = DataView.prototype[`set${key}`];
    const min = signed ? -(2 ** (size - 1)) : 0;
    const max = (2 ** (size - +signed)) - 1;
    return (0, mod_js_1.createShape)({
        metadata: intMetadata(signed, size),
        staticSize: byteSize,
        subEncode(buffer, value) {
            setMethod.call(buffer.view, buffer.index, value, true);
            buffer.index += byteSize;
        },
        subDecode(buffer) {
            const value = getMethod.call(buffer.view, buffer.index, true);
            buffer.index += byteSize;
            return value;
        },
        subAssert(assert) {
            assert.typeof(this, "number");
            assert.integer(this, min, max);
        },
    });
}
exports.i8 = _intNumber(true, 8);
exports.u16 = _intNumber(false, 16);
exports.i16 = _intNumber(true, 16);
exports.u32 = _intNumber(false, 32);
exports.i32 = _intNumber(true, 32);
function _intBigInt(signed, size) {
    const byteSize = size / 8;
    const chunks = size / 64;
    const getMethod = DataView.prototype[signed ? "getBigInt64" : "getBigUint64"];
    const min = signed ? -(1n << BigInt(size - 1)) : 0n;
    const max = (1n << BigInt(size - +signed)) - 1n;
    return (0, mod_js_1.createShape)({
        metadata: intMetadata(signed, size),
        staticSize: byteSize,
        subEncode(buffer, value) {
            for (let i = 0; i < chunks; i++) {
                buffer.view.setBigInt64(buffer.index, value, true);
                value >>= 64n;
                buffer.index += 8;
            }
        },
        subDecode(buffer) {
            let value = getMethod.call(buffer.view, buffer.index + (byteSize - 8), true);
            for (let i = chunks - 2; i >= 0; i--) {
                value <<= 64n;
                value |= buffer.view.getBigUint64(buffer.index + (i * 8), true);
            }
            buffer.index += byteSize;
            return value;
        },
        subAssert(assert) {
            assert.bigint(this, min, max);
        },
    });
}
exports.u64 = _intBigInt(false, 64);
exports.i64 = _intBigInt(true, 64);
exports.u128 = _intBigInt(false, 128);
exports.i128 = _intBigInt(true, 128);
exports.u256 = _intBigInt(false, 256);
exports.i256 = _intBigInt(true, 256);
const intLookup = { u8: exports.u8, i8: exports.i8, u16: exports.u16, i16: exports.i16, u32: exports.u32, i32: exports.i32, u64: exports.u64, i64: exports.i64, u128: exports.u128, i128: exports.i128, u256: exports.u256, i256: exports.i256 };
function int(signed, size) {
    const key = `${signed ? "i" : "u"}${size}`;
    return intLookup[key];
}
exports.int = int;
function intMetadata(signed, size) {
    return (0, mod_js_1.metadata)((0, mod_js_1.metadata)(`$.${signed ? "i" : "u"}${size}`), (0, mod_js_1.metadata)("$.int", int, signed, size));
}
//# sourceMappingURL=int.js.map