"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hex = exports.decodeHex = exports.encodeHexPrefixed = exports.encodeHex = void 0;
const mod_js_1 = require("../mod.js");
const transform_js_1 = require("./transform.js");
const encodeLookup = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
const decodeLookup = Array.from({ length: 128 }, (_, i) => parseInt(String.fromCharCode(i), 16) | 0);
function encodeHex(bytes) {
    let str = "";
    for (let i = 0; i < bytes.length; i++) {
        str += encodeLookup[bytes[i]];
    }
    return str;
}
exports.encodeHex = encodeHex;
function encodeHexPrefixed(bytes) {
    let str = "0x";
    for (let i = 0; i < bytes.length; i++) {
        str += encodeLookup[bytes[i]];
    }
    return str;
}
exports.encodeHexPrefixed = encodeHexPrefixed;
function decodeHex(hex) {
    if (hex.startsWith("0x"))
        hex = hex.slice(2);
    if (hex.length % 2 === 1)
        hex = "0" + hex;
    const array = new Uint8Array(hex.length >> 1);
    for (let i = 0; i < array.length; i++) {
        array[i] = (decodeLookup[hex.charCodeAt(i << 1)] << 4) | decodeLookup[hex.charCodeAt(i << 1 | 1)];
    }
    return array;
}
exports.decodeHex = decodeHex;
const hexRegex = /^(?:0x)?[\da-f]*$/i;
function hex($inner) {
    return (0, mod_js_1.withMetadata)((0, mod_js_1.metadata)("$.hex", hex, $inner), (0, transform_js_1.transform)({
        $base: $inner,
        encode: decodeHex,
        decode: encodeHex,
        assert(assert) {
            assert.typeof(this, "string");
            if (!hexRegex.test(assert.value)) {
                throw new mod_js_1.ShapeAssertError(this, assert.value, `${assert.path}: invalid hex`);
            }
        },
    }));
}
exports.hex = hex;
//# sourceMappingURL=hex.js.map