"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compact = exports.compactVisitor = void 0;
const mod_js_1 = require("../common/mod.js");
const constant_js_1 = require("./constant.js");
const int_js_1 = require("./int.js");
const object_js_1 = require("./object.js");
const tuple_js_1 = require("./tuple.js");
const MAX_U6 = 0b00111111;
const MAX_U14 = 16383;
const MAX_U30 = 1073741823;
exports.compactVisitor = new mod_js_1.ShapeVisitor();
function compact(shape) {
    return exports.compactVisitor.visit(shape);
}
exports.compact = compact;
function compactNumber($base) {
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.compact", compact, $base),
        staticSize: 5,
        subEncode(buffer, value) {
            if (value <= MAX_U6) {
                buffer.array[buffer.index++] = value << 2;
            }
            else if (value <= MAX_U14) {
                int_js_1.u16.subEncode(buffer, (value << 2) | 0b01);
            }
            else if (value <= MAX_U30) {
                // Because JS bitwise ops use *signed* 32-bit ints, this operation
                // produces negative values when `value >= 2 ** 29`. However, this is ok,
                // as `setUint32` correctly casts these negative values back to unsigned
                // 32-bit ints.
                int_js_1.u32.subEncode(buffer, (value << 2) | 0b10);
            }
            else {
                buffer.array[buffer.index++] = 0b11;
                int_js_1.u32.subEncode(buffer, value);
            }
        },
        subDecode(buffer) {
            switch (buffer.array[buffer.index] & 0b11) {
                case 0:
                    return buffer.array[buffer.index++] >> 2;
                case 1:
                    return int_js_1.u16.subDecode(buffer) >> 2;
                case 2:
                    // We use an unsigned right shift, as the default shift operator
                    // uses signed 32-bit ints, which would yield invalid values.
                    return int_js_1.u32.subDecode(buffer) >>> 2;
                default:
                    if (buffer.array[buffer.index++] !== 3)
                        throw new mod_js_1.ShapeDecodeError(this, buffer, "Out of range for U32");
                    return int_js_1.u32.subDecode(buffer);
            }
        },
        subAssert(assert) {
            $base.subAssert(assert);
        },
    });
}
const compactU8 = compactNumber(int_js_1.u8);
const compactU16 = compactNumber(int_js_1.u16);
const compactU32 = compactNumber(int_js_1.u32);
exports.compactVisitor.add(int_js_1.u8, () => compactU8);
exports.compactVisitor.add(int_js_1.u16, () => compactU16);
exports.compactVisitor.add(int_js_1.u32, () => compactU32);
function compactBigInt($base) {
    return (0, mod_js_1.createShape)({
        metadata: (0, mod_js_1.metadata)("$.compact", compact, $base),
        staticSize: 5,
        subEncode(buffer, value) {
            if (value <= 4294967295) {
                compactU32.subEncode(buffer, Number(value));
                return;
            }
            let extraBytes = 0;
            let _value = value >> 32n;
            while (_value > 0n) {
                _value >>= 8n;
                extraBytes++;
            }
            buffer.array[buffer.index++] = (extraBytes << 2) | 0b11;
            int_js_1.u32.subEncode(buffer, Number(value & 0xffffffffn));
            _value = value >> 32n;
            buffer.pushAlloc(extraBytes);
            for (let i = 0; i < extraBytes; i++) {
                buffer.array[buffer.index++] = Number(_value & 0xffn);
                _value >>= 8n;
            }
            buffer.popAlloc();
        },
        subDecode(buffer) {
            const b = buffer.array[buffer.index];
            if ((b & 0b11) < 3 || b === 3) {
                return BigInt(compactU32.subDecode(buffer));
            }
            const extraBytes = b >> 2;
            buffer.index++;
            let value = BigInt(int_js_1.u32.subDecode(buffer));
            for (let i = 0; i < extraBytes; i++) {
                value |= BigInt(buffer.array[buffer.index++]) << BigInt(32 + i * 8);
            }
            return value;
        },
        subAssert(assert) {
            $base.subAssert(assert);
        },
    });
}
const compactU64 = compactBigInt(int_js_1.u64);
const compactU128 = compactBigInt(int_js_1.u128);
const compactU256 = compactBigInt(int_js_1.u256);
exports.compactVisitor.add(int_js_1.u64, () => compactU64);
exports.compactVisitor.add(int_js_1.u128, () => compactU128);
exports.compactVisitor.add(int_js_1.u256, () => compactU256);
exports.compactVisitor.add((constant_js_1.constant), (shape) => shape);
exports.compactVisitor.add((tuple_js_1.tuple), (shape, ...entries) => {
    if (entries.length === 0)
        return shape;
    if (entries.length > 1)
        throw new Error("Cannot derive compact shape for tuples with more than one field");
    return (0, mod_js_1.withMetadata)((0, mod_js_1.metadata)("$.compact", (compact), shape), (0, tuple_js_1.tuple)(compact(entries[0])));
});
exports.compactVisitor.add((object_js_1.field), (shape, key, value) => {
    return (0, mod_js_1.withMetadata)((0, mod_js_1.metadata)("$.compact", compact, shape), (0, object_js_1.field)(key, compact(value)));
});
exports.compactVisitor.add((object_js_1.object), (shape, ...entries) => {
    if (entries.length === 0)
        return shape;
    if (entries.length > 1)
        throw new Error("Cannot derive compact shape for objects with more than one field");
    return (0, mod_js_1.withMetadata)((0, mod_js_1.metadata)("$.compact", compact, shape), compact(entries[0]));
});
//# sourceMappingURL=compact.js.map