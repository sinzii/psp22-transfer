import { AssertState } from "./assert.js";
import { DecodeBuffer, EncodeBuffer } from "./buffer.js";
import { ShapeAssertError, ShapeEncodeError } from "./util.js";
export function createShape(_shape) {
    const { staticSize, subEncode, subAssert, subDecode, metadata } = _shape;
    const shape = {
        // @ts-ignore https://gist.github.com/tjjfvi/ea194c4fce76dacdd60a0943256332aa
        __proto__: Shape.prototype,
        staticSize,
        subEncode,
        subDecode,
        subAssert,
        metadata,
    };
    return shape;
}
export function withMetadata(metadata, shape) {
    const result = {
        // @ts-ignore https://gist.github.com/tjjfvi/ea194c4fce76dacdd60a0943256332aa
        __proto__: Shape.prototype,
        ...shape,
        metadata: [...metadata, ...shape.metadata],
    };
    return result;
}
const shapeInspectCtx = new Map();
let shapeInspectIdN = 0;
const nodeCustomInspect = Symbol.for("nodejs.util.inspect.custom");
const denoCustomInspect = Symbol.for("Deno.customInspect");
class _Shape {
    [nodeCustomInspect](_0, _1, inspect) {
        return this._inspect(inspect);
    }
    [denoCustomInspect](inspect, opts) {
        return this._inspect((x) => inspect(x, opts));
    }
    _inspect(inspect) {
        let id = shapeInspectCtx.get(this);
        if (id !== undefined) {
            if (id === null) {
                shapeInspectCtx.set(this, id = shapeInspectIdN++);
            }
            return `$${id}`;
        }
        try {
            shapeInspectCtx.set(this, null);
            const metadata = this.metadata[0];
            const content = metadata
                ? metadata.type === "atomic"
                    ? metadata.name
                    : `${metadata.name}(${inspect(metadata.args).replace(/^\[(?: (.+) |(.+))\]$/s, "$1$2")})`
                : "?";
            id = shapeInspectCtx.get(this);
            return id !== null ? `$${id} = ${content}` : content;
        }
        finally {
            shapeInspectCtx.delete(this);
            if (shapeInspectCtx.size === 0)
                shapeInspectIdN = 0;
        }
    }
}
export class Shape extends _Shape {
    /** Encodes the value into a new Uint8Array (throws if async) */
    encode(value) {
        const buf = new EncodeBuffer(this.staticSize);
        this.subEncode(buf, value);
        if (buf.asyncCount)
            throw new ShapeEncodeError(this, value, "Attempted to synchronously encode an async shape");
        return buf.finish();
    }
    /** Asynchronously encodes the value into a new Uint8Array */
    async encodeAsync(value) {
        const buf = new EncodeBuffer(this.staticSize);
        this.subEncode(buf, value);
        return buf.finishAsync();
    }
    /** Decodes a value from the supplied Uint8Array */
    decode(array) {
        const buf = new DecodeBuffer(array);
        return this.subDecode(buf);
    }
    /** Requires the shape to have an explicit type annotation; if it doesn't, use `$.assert` instead. */
    assert(value) {
        assert(this, value);
    }
}
/** Asserts that the value is valid for the specified shape */
export function assert(shape, value) {
    shape.subAssert(new AssertState(value));
}
export function is(shape, value) {
    try {
        shape.subAssert(new AssertState(value));
        return true;
    }
    catch (e) {
        if (e instanceof ShapeAssertError) {
            return false;
        }
        else {
            throw e;
        }
    }
}
//# sourceMappingURL=shape.js.map