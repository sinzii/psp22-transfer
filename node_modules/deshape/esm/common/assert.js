import { ShapeAssertError } from "./util.js";
export class AssertState {
    constructor(value, pathPart = "value", parent) {
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
        });
        Object.defineProperty(this, "pathPart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: pathPart
        });
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parent
        });
    }
    get path() {
        return (this.parent?.path ?? "") + this.pathPart;
    }
    typeof(shape, type) {
        // deno-lint-ignore valid-typeof
        if (typeof this.value !== type) {
            throw new ShapeAssertError(shape, this.value, `typeof ${this.path} !== "${type}"`);
        }
    }
    nonNull(shape) {
        if (this.value == null) {
            throw new ShapeAssertError(shape, this.value, `${this.path} == null`);
        }
    }
    instanceof(shape, ctor) {
        if (!(this.value instanceof ctor)) {
            throw new ShapeAssertError(shape, this.value, `!(${this.path} instanceof ${ctor.name})`);
        }
    }
    key(shape, key) {
        this.typeof(shape, "object");
        this.nonNull(shape);
        if (!(key in this.value)) {
            throw new ShapeAssertError(shape, this.value, `!(${JSON.stringify(key)} in ${this.path})`);
        }
        const pathPart = typeof key === "string" && /^[^\W\d]\w*$/u.test(key)
            ? `.${key}`
            : `[${typeof key === "string" ? JSON.stringify(key) : key.toString()}]`;
        return new AssertState(this.value[key], pathPart, this);
    }
    equals(shape, value, label = `${value}`) {
        if (this.value !== value) {
            throw new ShapeAssertError(shape, this.value, `${this.path} !== ${label}`);
        }
    }
    integer(shape, min, max) {
        this.typeof(shape, "number");
        const value = this.value;
        if (value !== (value > 0 ? value >>> 0 : value >> 0)) {
            throw new ShapeAssertError(shape, this.value, `${this.path}: invalid int`);
        }
        if (value < min) {
            throw new ShapeAssertError(shape, this.value, `${this.path} < ${min}`);
        }
        if (value > max) {
            throw new ShapeAssertError(shape, this.value, `${this.path} > ${max}`);
        }
    }
    bigint(shape, min, max) {
        this.typeof(shape, "bigint");
        const value = this.value;
        if (value < min) {
            throw new ShapeAssertError(shape, this.value, `${this.path} < ${min}n`);
        }
        if (value > max) {
            throw new ShapeAssertError(shape, this.value, `${this.path} > ${max}n`);
        }
    }
}
//# sourceMappingURL=assert.js.map