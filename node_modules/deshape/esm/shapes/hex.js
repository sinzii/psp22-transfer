import { metadata, ShapeAssertError, withMetadata } from "../mod.js";
import { transform } from "./transform.js";
const encodeLookup = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
const decodeLookup = Array.from({ length: 128 }, (_, i) => parseInt(String.fromCharCode(i), 16) | 0);
export function encodeHex(bytes) {
    let str = "";
    for (let i = 0; i < bytes.length; i++) {
        str += encodeLookup[bytes[i]];
    }
    return str;
}
export function encodeHexPrefixed(bytes) {
    let str = "0x";
    for (let i = 0; i < bytes.length; i++) {
        str += encodeLookup[bytes[i]];
    }
    return str;
}
export function decodeHex(hex) {
    if (hex.startsWith("0x"))
        hex = hex.slice(2);
    if (hex.length % 2 === 1)
        hex = "0" + hex;
    const array = new Uint8Array(hex.length >> 1);
    for (let i = 0; i < array.length; i++) {
        array[i] = (decodeLookup[hex.charCodeAt(i << 1)] << 4) | decodeLookup[hex.charCodeAt(i << 1 | 1)];
    }
    return array;
}
const hexRegex = /^(?:0x)?[\da-f]*$/i;
export function hex($inner) {
    return withMetadata(metadata("$.hex", hex, $inner), transform({
        $base: $inner,
        encode: decodeHex,
        decode: encodeHex,
        assert(assert) {
            assert.typeof(this, "string");
            if (!hexRegex.test(assert.value)) {
                throw new ShapeAssertError(this, assert.value, `${assert.path}: invalid hex`);
            }
        },
    }));
}
//# sourceMappingURL=hex.js.map