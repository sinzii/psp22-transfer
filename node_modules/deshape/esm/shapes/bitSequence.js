import { createShape, metadata } from "../common/mod.js";
import { compact } from "./compact.js";
import { u32 } from "./int.js";
const compactU32 = compact(u32);
export class BitSequence {
    constructor(length = 0, data) {
        Object.defineProperty(this, "length", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: length
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const byteLength = Math.ceil(length / 8);
        data ??= new Uint8Array(byteLength);
        if (data.length !== byteLength) {
            throw new Error("Incorrectly sized Uint8Array passed to BitSequence constructor");
        }
        this.data = data;
    }
    static from(array) {
        const sequence = new BitSequence(array.length);
        for (let i = 0; i < array.length; i++) {
            sequence._setBit(i, array[i]);
        }
        return sequence;
    }
    get byteLength() {
        return this.data.length;
    }
    _hasBit(index) {
        return 0 <= index && index < this.length && index === Math.floor(index);
    }
    _getBit(index) {
        if (!this._hasBit(index))
            return undefined;
        const i = Math.floor(index / 8);
        const j = 7 - index % 8;
        return !!(this.data[i] & (1 << j));
    }
    _setBit(index, bit) {
        if (!this._hasBit(index))
            return false;
        const i = Math.floor(index / 8);
        const j = 7 - index % 8;
        this.data[i] = this.data[i] & ~(1 << j) | (+!!bit << j);
        return true;
    }
}
Object.setPrototypeOf(BitSequence.prototype, new Proxy(Object.prototype, {
    get: (target, k, receiver) => {
        const i = typeof k === "string" ? +k : NaN;
        if (isNaN(i))
            return Reflect.get(target, k, receiver);
        return receiver._getBit(i);
    },
    set: (target, k, v, receiver) => {
        const i = typeof k === "string" ? +k : NaN;
        if (isNaN(i))
            return Reflect.set(target, k, v, receiver);
        return receiver._setBit(i, v);
    },
}));
export const bitSequence = createShape({
    metadata: metadata("$.bitSequence"),
    staticSize: compactU32.staticSize,
    subEncode(buffer, value) {
        compactU32.subEncode(buffer, value.length);
        buffer.insertArray(value.data);
    },
    subDecode(buffer) {
        const length = compactU32.subDecode(buffer);
        const byteLength = Math.ceil(length / 8);
        return new BitSequence(length, buffer.array.subarray(buffer.index, buffer.index += byteLength));
    },
    subAssert(assert) {
        assert.instanceof(this, BitSequence);
    },
});
//# sourceMappingURL=bitSequence.js.map