import { createShape, metadata } from "../common/mod.js";
import { option } from "./option.js";
export function field(key, $value) {
    return createShape({
        metadata: metadata("$.field", field, key, $value),
        staticSize: $value.staticSize,
        subEncode(buffer, value) {
            $value.subEncode(buffer, value[key]);
        },
        subDecode(buffer) {
            return { [key]: $value.subDecode(buffer) };
        },
        subAssert(assert) {
            $value.subAssert(assert.key(this, key));
        },
    });
}
export function optionalField(key, $value) {
    const $option = option($value);
    return createShape({
        metadata: metadata("$.optionalField", optionalField, key, $value),
        staticSize: $value.staticSize,
        subEncode(buffer, value) {
            $option.subEncode(buffer, value[key]);
        },
        subDecode(buffer) {
            if (buffer.array[buffer.index++]) {
                return { [key]: $value.subDecode(buffer) };
            }
            else {
                return {};
            }
        },
        subAssert(assert) {
            assert.typeof(this, "object");
            assert.nonNull(this);
            if (key in assert.value) {
                $option.subAssert(assert.key(this, key));
            }
        },
    });
}
export function object(...members) {
    return createShape({
        metadata: metadata("$.object", (object), ...members),
        staticSize: members.map((x) => x.staticSize).reduce((a, b) => a + b, 0),
        subEncode: generateEncode(members),
        subDecode: generateDecode(members),
        subAssert(assert) {
            assert.typeof(this, "object");
            assert.nonNull(this);
            for (const member of members) {
                member.subAssert(assert);
            }
        },
    });
}
function generateEncode(members) {
    return (buffer, value) => {
        members.forEach(member => {
            member.subEncode(buffer, value);
        });
    };
}
function generateDecode(members) {
    return (buffer) => {
        return members.reduce((o, member) => {
            return { ...o, ...member.subDecode(buffer) };
        }, {});
    };
}
//# sourceMappingURL=object.js.map