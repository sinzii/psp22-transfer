import { createShape, metadata } from "../common/mod.js";
import { compact } from "./compact.js";
import { u32 } from "./int.js";
const compactU32 = compact(u32);
export function sizedArray($el, length) {
    return createShape({
        metadata: metadata("$.sizedArray", sizedArray, $el, length),
        staticSize: $el.staticSize * length,
        subEncode(buffer, value) {
            for (let i = 0; i < value.length; i++) {
                $el.subEncode(buffer, value[i]);
            }
        },
        subDecode(buffer) {
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el.subDecode(buffer);
            }
            return value;
        },
        subAssert(assert) {
            assert.instanceof(this, Array);
            assert.key(this, "length").equals(this, length);
            for (let i = 0; i < length; i++) {
                $el.subAssert(assert.key(this, i));
            }
        },
    });
}
export function array($el) {
    return createShape({
        metadata: metadata("$.array", array, $el),
        staticSize: compactU32.staticSize,
        subEncode(buffer, value) {
            compactU32.subEncode(buffer, value.length);
            if (value.length) {
                buffer.pushAlloc(value.length * $el.staticSize);
                for (let i = 0; i < value.length; i++) {
                    $el.subEncode(buffer, value[i]);
                }
                buffer.popAlloc();
            }
        },
        subDecode(buffer) {
            const length = compactU32.subDecode(buffer);
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el.subDecode(buffer);
            }
            return value;
        },
        subAssert(assert) {
            assert.instanceof(this, Array);
            for (let i = 0; i < assert.value.length; i++) {
                $el.subAssert(assert.key(this, i));
            }
        },
    });
}
export const uint8Array = createShape({
    metadata: metadata("$.uint8Array"),
    staticSize: compactU32.staticSize,
    subEncode(buffer, value) {
        compactU32.subEncode(buffer, value.length);
        buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
    },
    subDecode(buffer) {
        const length = compactU32.subDecode(buffer);
        const value = buffer.array.subarray(buffer.index, buffer.index + length);
        buffer.index += length;
        return value;
    },
    subAssert(assert) {
        assert.instanceof(this, Uint8Array);
    },
});
export function sizedUint8Array(length) {
    return createShape({
        metadata: metadata("$.sizedUint8Array", sizedUint8Array, length),
        // We could set `staticSize` to `length`, but in this case it will usually
        // more efficient to insert the array dynamically, rather than manually copy
        // the bytes.
        staticSize: 0,
        subEncode(buffer, value) {
            buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
        },
        subDecode(buffer) {
            return buffer.array.subarray(buffer.index, buffer.index += length);
        },
        subAssert(assert) {
            assert.instanceof(this, Uint8Array);
            assert.key(this, "length").equals(this, length);
        },
    });
}
//# sourceMappingURL=array.js.map