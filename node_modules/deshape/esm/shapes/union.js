import { createShape, metadata, ShapeAssertError, ShapeDecodeError } from "../common/mod.js";
import { constant } from "./constant.js";
import { field, object } from "./object.js";
export class Variant {
    constructor(tag, shape) {
        Object.defineProperty(this, "tag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: tag
        });
        Object.defineProperty(this, "shape", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: shape
        });
    }
}
export function variant(tag, ...members) {
    return new Variant(tag, object(...members));
}
export function taggedUnion(tagKey, members) {
    const tagToDiscriminant = Object.create(null);
    const discriminantToMember = Object.create(null);
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const { tag, shape } = members[discriminant];
        tagToDiscriminant[tag] = discriminant;
        discriminantToMember[discriminant] = object(field(tagKey, constant(tag)), shape);
    }
    return createShape({
        metadata: metadata("$.taggedUnion", taggedUnion, tagKey, members),
        staticSize: 1 + Math.max(...Object.values(discriminantToMember).map((x) => x.staticSize)),
        subEncode(buffer, value) {
            const discriminant = tagToDiscriminant[value[tagKey]];
            const $member = discriminantToMember[discriminant];
            buffer.array[buffer.index++] = discriminant;
            $member.subEncode(buffer, value);
        },
        subDecode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            const $member = discriminantToMember[discriminant];
            if (!$member) {
                throw new ShapeDecodeError(this, buffer, `No such member shape matching the discriminant \`${discriminant}\``);
            }
            return $member.subDecode(buffer);
        },
        subAssert(assert) {
            const assertTag = assert.key(this, tagKey);
            assertTag.typeof(this, "string");
            if (!(assertTag.value in tagToDiscriminant)) {
                throw new ShapeAssertError(this, assertTag.value, `${assertTag.path}: invalid tag`);
            }
            discriminantToMember[tagToDiscriminant[assertTag.value]].subAssert(assert);
        },
    });
}
export function literalUnion(members) {
    const keyToDiscriminant = new Map();
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const key = members[discriminant];
        keyToDiscriminant.set(key, discriminant);
    }
    return createShape({
        metadata: metadata("$.literalUnion", literalUnion, members),
        staticSize: 1,
        subEncode(buffer, value) {
            const discriminant = keyToDiscriminant.get(value);
            buffer.array[buffer.index++] = discriminant;
        },
        subDecode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            return members[discriminant];
        },
        subAssert(assert) {
            assert.typeof(this, "string");
            if (!keyToDiscriminant.has(assert.value)) {
                throw new ShapeAssertError(this, assert.value, `${assert.path} invalid value`);
            }
        },
    });
}
//# sourceMappingURL=union.js.map