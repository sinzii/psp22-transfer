var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ShapeMap_instances, _ShapeMap_inner, _ShapeMap_hexMemo, _ShapeMap_transformKey, _ShapeSet_instances, _ShapeSet_inner, _ShapeSet_hexMemo, _ShapeSet_transformValue;
import { metadata, withMetadata } from "../common/mod.js";
import { iterable } from "./iterable.js";
import { encodeHexPrefixed } from "./mod.js";
import { tuple } from "./tuple.js";
export function map($key, $value) {
    return withMetadata(metadata("$.map", map, $key, $value), iterable({
        $el: tuple($key, $value),
        calcLength: (map) => map.size,
        rehydrate: (values) => new ShapeMap($key, values),
        assert(assert) {
            assert.instanceof(this, ShapeMap);
        },
    }));
}
export function set($value) {
    return withMetadata(metadata("$.set", set, $value), iterable({
        $el: $value,
        calcLength: (set) => set.size,
        rehydrate: (values) => new ShapeSet($value, values),
        assert(assert) {
            assert.instanceof(this, ShapeSet);
        },
    }));
}
export class ShapeMap {
    constructor($key, entries) {
        _ShapeMap_instances.add(this);
        Object.defineProperty(this, "$key", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $key
        });
        _ShapeMap_inner.set(this, new Map());
        _ShapeMap_hexMemo.set(this, new WeakMap());
        if (entries) {
            for (const [key, value] of entries) {
                this.set(key, value);
            }
        }
    }
    get size() {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").size;
    }
    get [(_ShapeMap_inner = new WeakMap(), _ShapeMap_hexMemo = new WeakMap(), _ShapeMap_instances = new WeakSet(), _ShapeMap_transformKey = function _ShapeMap_transformKey(key) {
        return transformKey(this.$key, __classPrivateFieldGet(this, _ShapeMap_hexMemo, "f"), key);
    }, Symbol.toStringTag)]() {
        return "ShapeMap";
    }
    clear() {
        __classPrivateFieldGet(this, _ShapeMap_inner, "f").clear();
    }
    delete(key) {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").delete(__classPrivateFieldGet(this, _ShapeMap_instances, "m", _ShapeMap_transformKey).call(this, key));
    }
    forEach(callbackfn, thisArg) {
        __classPrivateFieldGet(this, _ShapeMap_inner, "f").forEach(([key, value]) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").get(__classPrivateFieldGet(this, _ShapeMap_instances, "m", _ShapeMap_transformKey).call(this, key))?.[1];
    }
    has(key) {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").has(__classPrivateFieldGet(this, _ShapeMap_instances, "m", _ShapeMap_transformKey).call(this, key));
    }
    set(key, value) {
        __classPrivateFieldGet(this, _ShapeMap_inner, "f").set(__classPrivateFieldGet(this, _ShapeMap_instances, "m", _ShapeMap_transformKey).call(this, key), [key, value]);
        return this;
    }
    [Symbol.iterator]() {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").values();
    }
    entries() {
        return __classPrivateFieldGet(this, _ShapeMap_inner, "f").values();
    }
    *keys() {
        for (const { 0: key } of this) {
            yield key;
        }
    }
    *values() {
        for (const { 1: value } of this) {
            yield value;
        }
    }
}
export class ShapeSet {
    constructor($value, values) {
        _ShapeSet_instances.add(this);
        Object.defineProperty(this, "$value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $value
        });
        _ShapeSet_inner.set(this, new Map());
        _ShapeSet_hexMemo.set(this, new WeakMap());
        if (values) {
            for (const value of values) {
                this.add(value);
            }
        }
    }
    get size() {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").size;
    }
    get [(_ShapeSet_inner = new WeakMap(), _ShapeSet_hexMemo = new WeakMap(), _ShapeSet_instances = new WeakSet(), _ShapeSet_transformValue = function _ShapeSet_transformValue(value) {
        return transformKey(this.$value, __classPrivateFieldGet(this, _ShapeSet_hexMemo, "f"), value);
    }, Symbol.toStringTag)]() {
        return "ShapeSet";
    }
    clear() {
        __classPrivateFieldGet(this, _ShapeSet_inner, "f").clear();
    }
    delete(value) {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").delete(__classPrivateFieldGet(this, _ShapeSet_instances, "m", _ShapeSet_transformValue).call(this, value));
    }
    forEach(callbackfn, thisArg) {
        __classPrivateFieldGet(this, _ShapeSet_inner, "f").forEach((value) => callbackfn.call(thisArg, value, value, this));
    }
    has(key) {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").has(__classPrivateFieldGet(this, _ShapeSet_instances, "m", _ShapeSet_transformValue).call(this, key));
    }
    add(value) {
        __classPrivateFieldGet(this, _ShapeSet_inner, "f").set(__classPrivateFieldGet(this, _ShapeSet_instances, "m", _ShapeSet_transformValue).call(this, value), value);
        return this;
    }
    [Symbol.iterator]() {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").values();
    }
    *entries() {
        for (const value of this) {
            yield [value, value];
        }
    }
    keys() {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").values();
    }
    values() {
        return __classPrivateFieldGet(this, _ShapeSet_inner, "f").values();
    }
}
function transformKey($key, hexMemo, key) {
    if (typeof key === "string") {
        // This ensures that the hexes won't ever clash with regular string keys,
        // but leaves most string keys unchanged for performance
        return key.startsWith("0x") ? "0x" + key : key;
    }
    if (typeof key !== "object" && typeof key !== "function" || !key) {
        return key;
    }
    const existingHex = hexMemo.get(key);
    if (existingHex)
        return existingHex;
    const hex = encodeHexPrefixed($key.encode(key));
    hexMemo.set(key, hex);
    return hex;
}
//# sourceMappingURL=collections.js.map