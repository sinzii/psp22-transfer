export declare class EncodeBuffer {
    context: Context;
    finishedArrays: (Uint8Array | EncodeBuffer)[];
    finishedSize: number;
    queuedArrays: Uint8Array[];
    array: Uint8Array;
    view: DataView;
    index: number;
    asyncCount: number;
    asyncPromise: Promise<void>;
    asyncResolve: (value: void | Promise<void>) => void;
    /** Creates a new EncodeBuffer with a specified initial size/buffer */
    constructor(init: number | Uint8Array, context?: Context);
    /**
     * Inserts a Uint8Array at the current position in the buffer.
     * This does not consume any of the pre-allocated space.
     */
    insertArray(buffer: Uint8Array): void;
    /**
     * Allocates more space in the EncodeBuffer.
     * `.popAlloc()` must be called after this space is used.
     */
    pushAlloc(size: number): void;
    /**
     * Finishes the current array and resumes writing on the previous array.
     * Must be called after `.pushAlloc()`.
     */
    popAlloc(): void;
    /**
     * Creates a sub-buffer that can be written into asynchronously.
     * The buffer passed to the callback should not be used after the returned promise resolves.
     */
    writeAsync(length: number, fn: (buffer: EncodeBuffer) => Promise<void>): void;
    /**
     * Creates a sub-buffer that can be written into later to insert data into the middle of the array.
     * `.close()` must be called after the cursor is done being written into.
     * The cursor should not be used after `.close()` is called.
     * If the cursor will be written into asynchronously, the buffer must be held open with `.waitFor()`.
     */
    createCursor(length: number): EncodeBuffer & {
        close(): void;
    };
    /**
     * Immediately invokes the callback, and holds the buffer open until the
     * returned promise resolves.
     */
    waitFor(fn: () => Promise<void>): void;
    /**
     * Consumes `length` allocated bytes without writing anything, and returns the skipped subarray.
     * Anything written into the returned array will not affect the buffer,
     * except if it is later reincorporated e.g. via `.insertArray()`.
     * Rather niche.
     */
    stealAlloc(length: number): Uint8Array;
    /**
     * Invokes the callback once buffer's async tasks finish, and holds this
     * buffer open until the callback returns.
     */
    waitForBuffer(buffer: EncodeBuffer, fn: () => void): void;
    /**
     * Finishes the current array, and returns a Uint8Array containing everything written.
     * The EncodeBuffer is left in an undefined state, and should not be used afterwards.
     * Throws if asynchronous writes are still pending.
     */
    finish(): Uint8Array;
    /**
     * Finishes the current array, and returns a Uint8Array containing everything written.
     * The EncodeBuffer is left in an undefined state, and should not be used afterwards.
     */
    finishAsync(): Promise<Uint8Array>;
    /** Copies all data from finishedArrays into fullArray */
    _finishInto(fullArray: Uint8Array, index: number): number;
    /**
     * Pushes the data written in array to finishedArrays.
     * Leaves the buffer in an invalid state -- array and index must be updated.
     */
    _commitWritten(): void;
    /** Sets array and updates view */
    _setArray(array: Uint8Array): void;
}
export declare class DecodeBuffer {
    array: Uint8Array;
    view: DataView;
    index: number;
    context: Context;
    constructor(array: Uint8Array);
}
export declare class Context {
    private map;
    get<T>(T: new () => T): T;
}
