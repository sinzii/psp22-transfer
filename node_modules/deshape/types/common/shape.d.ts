import { AssertState } from "./assert.js";
import { DecodeBuffer, EncodeBuffer } from "./buffer.js";
import { Metadata } from "./metadata.js";
export type Input<T extends AnyShape> = T extends Shape<infer I, unknown> ? I : never;
export type Output<T extends AnyShape> = T extends Shape<never, infer O> ? O : never;
export declare function createShape<I, O = I>(_shape: ThisType<Shape<I, O>> & Pick<Shape<I, O>, "subEncode" | "subDecode" | "subAssert" | "staticSize" | "metadata">): Shape<I, O>;
type NoInfer<T> = T extends infer U ? U : never;
export declare function withMetadata<I, O>(metadata: Metadata<NoInfer<I>, NoInfer<O>>, shape: Shape<I, O>): Shape<I, O>;
declare const nodeCustomInspect: unique symbol;
declare const denoCustomInspect: unique symbol;
declare abstract class _Shape {
    private [nodeCustomInspect];
    private [denoCustomInspect];
    private _inspect;
}
export type AnyShape = Shape<never, unknown>;
export type InShape<I> = Shape<I, unknown>;
export type OutShape<O> = Shape<never, O>;
export declare abstract class Shape<in I, out O = I> extends _Shape implements AnyShape {
    /** A static estimation of the size, which may be an under- or over-estimate */
    abstract staticSize: number;
    /** Encodes the value into the supplied buffer, which should have at least `staticSize` free byte. */
    abstract subEncode: (buffer: EncodeBuffer, value: I) => void;
    /** Decodes the value from the supplied buffer */
    abstract subDecode: (buffer: DecodeBuffer) => O;
    /** Asserts that the value is valid for this shape */
    abstract subAssert: (state: AssertState) => void;
    /** An array with metadata representing the construction of this shape */
    abstract metadata: Metadata<I, O>;
    /** Encodes the value into a new Uint8Array (throws if async) */
    encode(value: I): Uint8Array;
    /** Asynchronously encodes the value into a new Uint8Array */
    encodeAsync(value: I): Promise<Uint8Array>;
    /** Decodes a value from the supplied Uint8Array */
    decode(array: Uint8Array): O;
    /** Requires the shape to have an explicit type annotation; if it doesn't, use `$.assert` instead. */
    assert(value: unknown): asserts value is I;
}
/** Asserts that the value is valid for the specified shape */
export declare function assert<I>(shape: Shape<I, unknown>, value: unknown): asserts value is I;
export declare function is<T>(shape: Shape<T>, value: unknown): value is T;
export {};
