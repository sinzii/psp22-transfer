import type { DecodeBuffer } from "./buffer.js";
import type { AnyShape } from "./shape.js";
export declare abstract class ShapeError extends Error {
    readonly shape: AnyShape;
    constructor(shape: AnyShape, message: string);
}
export declare class ShapeAssertError extends ShapeError {
    readonly value: unknown;
    readonly name = "ShapeAssertError";
    constructor(shape: AnyShape, value: unknown, message: string);
}
export declare class ShapeEncodeError extends ShapeError {
    readonly value: unknown;
    readonly name = "ShapeEncodeError";
    constructor(shape: AnyShape, value: unknown, message: string);
}
export declare class ShapeDecodeError extends ShapeError {
    readonly buffer: DecodeBuffer;
    readonly name = "ShapeDecodeError";
    constructor(shape: AnyShape, buffer: DecodeBuffer, message: string);
}
export type Expand<T> = T extends T ? {
    [K in keyof T]: T[K];
} : never;
export type U2I<U> = (U extends U ? (u: U) => 0 : never) extends (i: infer I) => 0 ? Extract<I, U> : never;
type _Narrow<T, U> = [U] extends [T] ? U : Extract<T, U>;
export type Narrow<T = unknown> = _Narrow<T, 0 | number & {}> | _Narrow<T, 0n | bigint & {}> | _Narrow<T, "" | string & {}> | _Narrow<T, boolean> | _Narrow<T, symbol> | _Narrow<T, []> | _Narrow<T, {
    [_: PropertyKey]: Narrow;
}> | (T extends object ? {
    [K in keyof T]: Narrow<T[K]>;
} : never) | Extract<{} | null | undefined, T>;
export {};
