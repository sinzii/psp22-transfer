import { Args, OmitNever, Pop, SubstrateAddress } from '../types.js';
import { ConstructorTxOptions, ContractDeployer, GenericContractApi } from 'dedot/contracts';
import { ISubmittableResult } from 'dedot/types';
type UseDeployerTx<A extends GenericContractApi = GenericContractApi> = OmitNever<{
    [K in keyof A['constructorTx']]: K extends string ? (K extends `${infer Literal}` ? Literal : never) : never;
}>;
type UseDeployerTxReturnType<T extends GenericContractApi = GenericContractApi, M extends keyof UseDeployerTx<T> = keyof UseDeployerTx<T>> = {
    signAndSend(parameters: {
        txOptions?: Partial<ConstructorTxOptions>;
        callback?: (result: ISubmittableResult, contractAddress?: SubstrateAddress) => void;
    } & Args<Pop<Parameters<T['constructorTx'][M]>>>): Promise<void>;
    inProgress: boolean;
    inBestBlockProgress: boolean;
};
/**
 * A hook for managing contract deployment transactions.
 *
 * This hook provides functionality to sign and send a contract deployment transaction,
 * and tracks the progress of the transaction. It's similar to the useContractTx hook
 * but specifically for contract deployment.
 *
 * @param {ContractDeployer<T> | undefined} deployer - The contract deployer instance
 * @param {M} fn - The key of the constructor function to be called
 *
 * @returns {UseDeployerTxReturnType<T, M>} An object containing:
 *   - signAndSend: A function to sign and send the deployment transaction
 *   - inProgress: A boolean indicating if a transaction is in progress. It's set to true when
 *     the transaction starts and turns back to false when the transaction status is finalized,
 *     invalid, or dropped.
 *   - inBestBlockProgress: A boolean indicating if the transaction is being processed but not
 *     yet included in the best block. It's set to true when the transaction starts and turns
 *     back to false when the transaction is included in the best block, which happens before
 *     finalization.
 */
export declare function useDeployerTx<T extends GenericContractApi = GenericContractApi, M extends keyof UseDeployerTx<T> = keyof UseDeployerTx<T>>(deployer: ContractDeployer<T> | undefined, fn: M): UseDeployerTxReturnType<T, M>;
export declare function deployerTx<T extends GenericContractApi = GenericContractApi, M extends keyof UseDeployerTx<T> = keyof UseDeployerTx<T>>(parameters: {
    deployer: ContractDeployer<T>;
    caller: string;
    fn: M;
    txOptions?: Partial<ConstructorTxOptions>;
    callback?: (result: ISubmittableResult) => void;
} & Args<Pop<Parameters<T['tx'][M]>>>): Promise<void>;
export {};
