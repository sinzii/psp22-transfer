import { useCallback, useEffect, useState } from 'react';
import { useDeepDeps } from './internal/index.js';
import { useTypink } from './useTypink.js';
/**
 * A React hook for querying a smart contract.
 *
 * This hook manages the state of a contract query, including loading state,
 * query results, and error handling. It automatically fetches data when the
 * contract, function, or arguments change.
 *
 * @param parameters - An object containing the query parameters
 * @param parameters.contract - The contract instance to query
 * @param parameters.fn - The name of the query function to call on the contract
 * @param parameters.options - Optional contract call options
 * @param parameters.args - The arguments to pass to the query function
 * @param parameters.watch - Whether to watch the chain for changes and refresh the query
 *
 * @returns An object containing the result of the query and:
 *   - isLoading: A boolean indicating whether the query is in progress
 *   - refresh: A function to manually trigger a refresh of the query
 *   - error: Any error that occurred during the query
 */
export function useContractQuery(parameters) {
    // TODO replace loading tracking state with tanstack
    const { client } = useTypink();
    const [isLoading, setIsLoading] = useState(true);
    const [isRefreshing, setIsRefreshing] = useState(false);
    const [result, setResult] = useState();
    const [error, setError] = useState();
    const { contract, fn, args = [], options, watch = false } = parameters;
    const deps = useDeepDeps([contract, fn, args, options]);
    useEffect(() => {
        let mounted = true;
        const fetchData = async () => {
            if (!contract || !fn || !args)
                return;
            try {
                setIsLoading(true);
                const result = await contract.query[fn](...args, options);
                if (mounted) {
                    setResult(result);
                    setError(undefined);
                    setIsLoading(false);
                }
            }
            catch (error) {
                console.error('Error in contract query:', error);
                if (mounted) {
                    setResult(undefined);
                    setError(error);
                    setIsLoading(false);
                }
            }
        };
        fetchData().catch(console.error);
        return () => {
            mounted = false;
        };
    }, deps);
    const refresh = useCallback(async () => {
        if (!contract || !fn || !args)
            return;
        try {
            setIsRefreshing(true);
            const result = await contract.query[fn](...args, options);
            setResult(result);
            setError(undefined);
            setIsRefreshing(false);
        }
        catch (error) {
            console.error('Error when refreshing the query:', error);
            setResult(undefined);
            setError(error);
            setIsRefreshing(false);
        }
    }, deps);
    useEffect(() => {
        if (!client || !watch)
            return;
        let unsub;
        let done = false;
        client.query.system
            .number((_) => {
            refresh();
        })
            .then((x) => {
            if (done) {
                x().catch(console.error);
            }
            else {
                unsub = x;
            }
        })
            .catch(console.error);
        return () => {
            done = true;
            unsub && unsub();
        };
    }, useDeepDeps([client, refresh, watch]));
    return {
        isLoading,
        refresh,
        isRefreshing,
        ...(result || {}),
        error,
    };
}
