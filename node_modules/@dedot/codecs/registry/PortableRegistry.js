import { blake2_256, hexToU8a, isObject, isU8a, u8aToHex } from '@dedot/utils';
import { $Extrinsic, } from '../codecs/index.js';
import { TypeRegistry } from './TypeRegistry.js';
/**
 * Codec registry for portable types from metadata
 */
export class PortableRegistry extends TypeRegistry {
    #metadata;
    #hasher;
    constructor(metadata, hasher) {
        super(metadata.types);
        this.#metadata = metadata;
        this.#hasher = hasher || blake2_256;
    }
    get $Extrinsic() {
        return $Extrinsic(this);
    }
    get metadata() {
        return this.#metadata;
    }
    hash(input) {
        return this.#hasher(input);
    }
    hashAsHex(input) {
        if (isU8a(input)) {
            return u8aToHex(this.hash(input));
        }
        else {
            return u8aToHex(this.hash(hexToU8a(input)));
        }
    }
    setHasher(hasher) {
        this.#hasher = hasher;
    }
    findErrorMeta(errorInfo) {
        const moduleError = isObject(errorInfo) && errorInfo.type === 'Module' ? errorInfo.value : errorInfo;
        const targetPallet = this.metadata.pallets.find((p) => p.index === moduleError.index);
        if (!targetPallet || !targetPallet.error)
            return;
        const def = this.metadata.types[targetPallet.error];
        if (!def)
            return;
        const { type, value } = def.typeDef;
        if (type !== 'Enum')
            return;
        const errorDef = value.members.find(({ index }) => index === hexToU8a(moduleError.error)[0]);
        if (!errorDef)
            return;
        return {
            ...errorDef,
            fieldCodecs: errorDef.fields.map(({ typeId }) => this.findCodec(typeId)),
            pallet: targetPallet.name,
            palletIndex: targetPallet.index,
        };
    }
    findType(typeId) {
        const type = this.types[typeId];
        if (!type) {
            throw new Error(`Cannot find portable type for id: ${typeId}`);
        }
        return type;
    }
    /**
     * Custom enum labels for different types
     *
     * @param typeId
     */
    getEnumOptions(typeId) {
        const { extrinsic: { callTypeId }, outerEnums: { eventEnumTypeId, errorEnumTypeId }, } = this.metadata;
        if (typeId === eventEnumTypeId) {
            return {
                tagKey: 'pallet',
                valueKey: 'palletEvent',
            };
        }
        else if (typeId === callTypeId) {
            return {
                tagKey: 'pallet',
                valueKey: 'palletCall',
            };
        }
        else if (typeId === errorEnumTypeId) {
            return {
                tagKey: 'pallet',
                valueKey: 'palletError',
            };
        }
        else if (this.getFieldTypeIdsFromEnum(eventEnumTypeId).includes(typeId) ||
            this.getFieldTypeIdsFromEnum(errorEnumTypeId).includes(typeId)) {
            return {
                tagKey: 'name',
                valueKey: 'data',
            };
        }
        else if (this.getFieldTypeIdsFromEnum(callTypeId).includes(typeId)) {
            return {
                tagKey: 'name',
                valueKey: 'params',
            };
        }
        return {
            tagKey: 'type',
            valueKey: 'value',
        };
    }
    getFieldTypeIdsFromEnum(typeId) {
        try {
            const eventType = this.findType(typeId);
            if (eventType.typeDef.type === 'Enum') {
                return eventType.typeDef.value.members.map((m) => m.fields[0].typeId);
            }
        }
        catch {
            // In-case of metadata v14, we don't have an explicit type for RuntimeError
            // For now, we just ignore the error and return an empty array
        }
        return [];
    }
}
