import * as $ from '@dedot/shape';
import { normalizeName, stringPascalCase } from '@dedot/utils';
import { $AccountId20, $AccountId32, $Bytes, $Data, $Digest, $DigestItem, $Era, $EthereumAddress, $Hash, $Header, $MultiAddress, $RawBytes, $UncheckedExtrinsic, } from '../codecs/index.js';
const KNOWN_CODECS = {
    'sp_core::crypto::AccountId32': $AccountId32,
    'sp_runtime::generic::era::Era': $Era,
    'sp_runtime::multiaddress::MultiAddress': $MultiAddress,
    'fp_account::AccountId20': $AccountId20,
    'account::AccountId20': $AccountId20,
    'polkadot_runtime_common::claims::EthereumAddress': $EthereumAddress,
    'sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic': $UncheckedExtrinsic,
    'pallet_identity::types::Data': $Data,
    'sp_runtime::generic::digest::Digest': $Digest,
    'sp_runtime::generic::digest::DigestItem': $DigestItem,
    'sp_runtime::generic::header::Header': $Header,
    'ink_primitives::types::Hash': $Hash,
    'ink_primitives::types::AccountId': $AccountId32,
};
export class TypeRegistry {
    types;
    #cache;
    constructor(types) {
        if (Array.isArray(types)) {
            this.types = types.reduce((o, one) => {
                o[one.id] = one;
                return o;
            }, {});
        }
        else {
            this.types = types;
        }
        this.#cache = new Map();
    }
    findType(typeId) {
        const type = this.types[typeId];
        if (!type) {
            throw new Error(`Cannot find portable type for id: ${typeId}`);
        }
        return type;
    }
    findCodec(typeId) {
        const typeDef = this.findType(typeId);
        if (typeDef && typeDef.path.length > 0) {
            try {
                const fullPath = typeDef.path.join('::');
                if (!!KNOWN_CODECS[fullPath]) {
                    // TODO Check codec structure matches with corresponding portable codec
                    // Preparing for customizing primitive codecs
                    return KNOWN_CODECS[fullPath];
                }
            }
            catch (e) {
                // ignore
            }
        }
        if (this.#cache.has(typeId)) {
            return this.#cache.get(typeId);
        }
        // A placeholder codec for typeId so if this typeId is used in the `#createCodec`
        // the recursion will be resolved
        this.#cache.set(typeId, $.deferred(() => this.#cache.get(typeId) || $RawBytes));
        const $codec = this.#createCodec(typeId);
        this.#cache.set(typeId, $codec);
        return $codec;
    }
    // Create codec for a portable type from its type definition
    // TODO refactor this!
    #createCodec = (typeId) => {
        const def = this.types[typeId];
        if (!def) {
            throw new Error(`Type id not found ${typeId}`);
        }
        const { typeDef, path } = def;
        const { type, value } = typeDef;
        if (type === 'Struct') {
            const { fields } = value;
            if (fields.length === 0) {
                return $.Struct({});
            }
            else if (fields[0].name === undefined) {
                if (fields.length === 1) {
                    return this.findCodec(fields[0].typeId);
                }
                else {
                    return $.Tuple(...fields.map((x) => this.findCodec(x.typeId)));
                }
            }
            else {
                return $.Struct(fields.reduce((o, field) => ({
                    ...o,
                    [normalizeName(field.name)]: this.findCodec(field.typeId),
                }), {}));
            }
        }
        else if (type === 'Tuple') {
            const { fields } = value;
            if (fields.length === 0) {
                return $.Tuple();
            }
            else if (fields.length === 1) {
                // wrapper
                return this.findCodec(fields[0]);
            }
            else {
                return $.Tuple(...fields.map((x) => this.findCodec(x)));
            }
        }
        else if (type === 'Enum') {
            const { members } = value;
            // Handle optional field
            if (path.join('::') === 'Option') {
                const some = members.find((one) => one.name === 'Some');
                if (some) {
                    const $codec = this.findCodec(some.fields[0].typeId);
                    if ($codec.metadata[0].name === '$.bool') {
                        return $.optionBool;
                    }
                    else {
                        return $.Option($codec);
                    }
                }
            }
            else if (path.join('::') === 'Result') {
                const ok = members.find((one) => one.name === 'Ok');
                const err = members.find((one) => one.name === 'Err');
                if (ok && err) {
                    const $OkCodec = this.findCodec(ok.fields[0].typeId);
                    const $ErrCodec = this.findCodec(err.fields[0].typeId);
                    return $.Result($OkCodec, $ErrCodec);
                }
            }
            if (members.length === 0) {
                return $.Null;
            }
            else if (members.every((x) => x.fields.length === 0)) {
                const enumMembers = {};
                for (const { index, name } of members) {
                    enumMembers[index] = name;
                }
                return $.FlatEnum(enumMembers);
            }
            else {
                const enumMembers = {};
                for (const { fields, name, index } of members) {
                    const keyName = stringPascalCase(name);
                    if (fields.length === 0) {
                        enumMembers[keyName] = { index };
                    }
                    else if (fields[0].name === undefined) {
                        const $value = fields.length === 1
                            ? this.findCodec(fields[0].typeId)
                            : $.Tuple(...fields.map((f) => this.findCodec(f.typeId)));
                        enumMembers[keyName] = { index, value: $value };
                    }
                    else {
                        enumMembers[keyName] = {
                            index,
                            value: $.Struct(fields.reduce((o, field) => ({
                                ...o,
                                [normalizeName(field.name)]: this.findCodec(field.typeId),
                            }), {})),
                        };
                    }
                }
                return $.Enum(enumMembers, this.getEnumOptions(typeId));
            }
        }
        else if (type === 'Sequence') {
            const $inner = this.findCodec(typeDef.value.typeParam);
            if ($inner === $.u8) {
                return $Bytes;
            }
            else {
                return $.Vec($inner);
            }
        }
        else if (type === 'SizedVec') {
            const $inner = this.findCodec(typeDef.value.typeParam);
            if ($inner === $.u8) {
                return $.FixedHex(typeDef.value.len);
            }
            else {
                return $.SizedVec($inner, typeDef.value.len);
            }
        }
        else if (type === 'Primitive') {
            const kind = typeDef.value.kind;
            if (kind === 'char') {
                return $.str;
            }
            const $codec = $[kind];
            if (!$codec) {
                throw new Error(`Invalid primitive kind: ${kind}`);
            }
            return $codec;
        }
        else if (type === 'Compact') {
            return $.compact(this.findCodec(typeDef.value.typeParam));
        }
        else if (type === 'BitSequence') {
            return $.bitSequence;
        }
        throw Error(`Not support yet! ${JSON.stringify(def, null, 2)}`);
    };
    getEnumOptions(_typeId) {
        return {
            tagKey: 'type',
            valueKey: 'value',
        };
    }
}
