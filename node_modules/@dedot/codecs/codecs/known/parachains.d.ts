import * as $ from '@dedot/shape';
/**
 * Approval voting configuration parameters
 */
export declare const $ApprovalVotingParams: $.Shape<{
    maxApprovalCoalesceCount: number;
}, {
    maxApprovalCoalesceCount: number;
}>;
export type ApprovalVotingParams = $.Input<typeof $ApprovalVotingParams>;
/**
 * Identity that parachain validators use when signing validation messages.
 */
export declare const $ValidatorId: $.Shape<import("../generic/AccountId32.js").AccountId32Like, import("../generic/AccountId32.js").AccountId32>;
export type ValidatorId = $.Input<typeof $ValidatorId>;
/**
 * Index of the validator is used as a lightweight replacement of the `ValidatorId` when
 * appropriate.
 */
export declare const $ParaValidatorIndex: $.Shape<number, number>;
export type ParaValidatorIndex = $.Input<typeof $ParaValidatorIndex>;
/**
 * A helper data-type for tracking validator-group rotations.
 */
export declare const $GroupRotationInfo: $.Shape<{
    sessionStartBlock: number;
    groupRotationFrequency: number;
    now: number;
}, {
    sessionStartBlock: number;
    groupRotationFrequency: number;
    now: number;
}>;
export type GroupRotationInfo = $.Input<typeof $GroupRotationInfo>;
/**
 * Unique identifier of a parachain.
 */
export declare const $ParaId: $.Shape<number, number>;
export type ParaId = $.Input<typeof $ParaId>;
/**
 * Identity that collators use.
 */
export declare const $CollatorId: $.Shape<`0x${string}`, `0x${string}`>;
export type CollatorId = $.Input<typeof $CollatorId>;
/**
 * Information about a core which is currently occupied.
 */
export declare const $ScheduledCore: $.Shape<{
    paraId: number;
    collator: `0x${string}` | undefined;
}, {
    paraId: number;
    collator: `0x${string}` | undefined;
}>;
export type ScheduledCore = $.Input<typeof $ScheduledCore>;
/**
 * The unique (during session) index of a validator group.
 */
export declare const $GroupIndex: $.Shape<number, number>;
export type GroupIndex = $.Input<typeof $GroupIndex>;
/**
 * Unit type wrapper around [`type@Hash`] that represents a candidate hash.
 *
 * This type is produced by `CandidateReceipt::hash`.
 *
 * This type makes it easy to enforce that a hash is a candidate hash on the type level.
 */
export declare const $CandidateHash: $.Shape<`0x${string}`, `0x${string}`>;
export type CandidateHash = $.Input<typeof $CandidateHash>;
/**
 * Signature on candidate's block data by a collator.
 */
export declare const $CollatorSignature: $.Shape<`0x${string}`, `0x${string}`>;
export type CollatorSignature = $.Input<typeof $CollatorSignature>;
/**
 * Unit type wrapper around [`type@Hash`] that represents the blake2-256 hash
 * of validation code in particular.
 *
 * This type is produced by [`ValidationCode::hash`].
 *
 * This type makes it easy to enforce that a hash is a validation code hash on the type level.
 */
export declare const $ValidationCodeHash: $.Shape<`0x${string}`, `0x${string}`>;
export type ValidationCodeHash = $.Input<typeof $ValidationCodeHash>;
/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
export declare const $CandidateDescriptor: $.Shape<{
    paraId: number;
    relayParent: `0x${string}`;
    collator: `0x${string}`;
    persistedValidationDataHash: `0x${string}`;
    povHash: `0x${string}`;
    erasureRoot: `0x${string}`;
    signature: `0x${string}`;
    paraHead: `0x${string}`;
    validationCodeHash: `0x${string}`;
}, {
    paraId: number;
    relayParent: `0x${string}`;
    collator: `0x${string}`;
    persistedValidationDataHash: `0x${string}`;
    povHash: `0x${string}`;
    erasureRoot: `0x${string}`;
    signature: `0x${string}`;
    paraHead: `0x${string}`;
    validationCodeHash: `0x${string}`;
}>;
export type CandidateDescriptor = $.Input<typeof $CandidateDescriptor>;
/**
 * Information about a core which is currently occupied.
 */
export declare const $OccupiedCore: $.Shape<{
    nextUpOnAvailable: {
        paraId: number;
        collator: `0x${string}` | undefined;
    } | undefined;
    occupiedSince: number;
    timeOutAt: number;
    nextUpOnTimeOut: {
        paraId: number;
        collator: `0x${string}` | undefined;
    } | undefined;
    availability: $.BitSequence;
    groupResponsible: number;
    candidateHash: `0x${string}`;
    candidateDescriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
}, {
    nextUpOnAvailable: {
        paraId: number;
        collator: `0x${string}` | undefined;
    } | undefined;
    occupiedSince: number;
    timeOutAt: number;
    nextUpOnTimeOut: {
        paraId: number;
        collator: `0x${string}` | undefined;
    } | undefined;
    availability: $.BitSequence;
    groupResponsible: number;
    candidateHash: `0x${string}`;
    candidateDescriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
}>;
export type OccupiedCore = $.Input<typeof $OccupiedCore>;
/**
 * The state of a particular availability core.
 */
export declare const $CoreState: $.Shape<{
    type: "Occupied";
    value: {
        nextUpOnAvailable: {
            paraId: number;
            collator: `0x${string}` | undefined;
        } | undefined;
        occupiedSince: number;
        timeOutAt: number;
        nextUpOnTimeOut: {
            paraId: number;
            collator: `0x${string}` | undefined;
        } | undefined;
        availability: $.BitSequence;
        groupResponsible: number;
        candidateHash: `0x${string}`;
        candidateDescriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
    };
} | {
    type: "Scheduled";
    value: {
        paraId: number;
        collator: `0x${string}` | undefined;
    };
} | {
    type: "Free";
}, {
    type: "Occupied";
    value: {
        nextUpOnAvailable: {
            paraId: number;
            collator: `0x${string}` | undefined;
        } | undefined;
        occupiedSince: number;
        timeOutAt: number;
        nextUpOnTimeOut: {
            paraId: number;
            collator: `0x${string}` | undefined;
        } | undefined;
        availability: $.BitSequence;
        groupResponsible: number;
        candidateHash: `0x${string}`;
        candidateDescriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
    };
} | {
    type: "Scheduled";
    value: {
        paraId: number;
        collator: `0x${string}` | undefined;
    };
} | {
    type: "Free";
}>;
export type CoreState = $.Input<typeof $CoreState>;
/**
 * An assumption being made about the state of an occupied core.
 */
export declare const $OccupiedCoreAssumption: $.Shape<"Free" | "Included" | "TimedOut", "Free" | "Included" | "TimedOut">;
export type OccupiedCoreAssumption = $.Input<typeof $OccupiedCoreAssumption>;
/**
 * Parachain head data included in the chain.
 */
export declare const $HeadData: $.Shape<`0x${string}`, `0x${string}`>;
export type HeadData = $.Input<typeof $HeadData>;
/**
 * The validation data provides information about how to create the inputs for validation of a
 * candidate. This information is derived from the chain state and will vary from para to para,
 * although some fields may be the same for every para.
 *
 * Since this data is used to form inputs to the validation function, it needs to be persisted by
 * the availability system to avoid dependence on availability of the relay-chain state.
 *
 * Furthermore, the validation data acts as a way to authorize the additional data the collator
 * needs to pass to the validation function. For example, the validation function can check whether
 * the incoming messages (e.g. downward messages) were actually sent by using the data provided in
 * the validation data using so called MQC heads.
 *
 * Since the commitments of the validation function are checked by the relay-chain, secondary
 * checkers can rely on the invariant that the relay-chain only includes para-blocks for which
 * these checks have already been done. As such, there is no need for the validation data used to
 * inform validators and collators about the checks the relay-chain will perform to be persisted by
 * the availability system.
 *
 * The `PersistedValidationData` should be relatively lightweight primarily because it is
 * constructed during inclusion for each candidate and therefore lies on the critical path of
 * inclusion.
 */
export declare const $PersistedValidationData: $.Shape<{
    parentHead: `0x${string}`;
    relayParentNumber: number;
    relayParentStorageRoot: `0x${string}`;
    maxPovSize: number;
}, {
    parentHead: `0x${string}`;
    relayParentNumber: number;
    relayParentStorageRoot: `0x${string}`;
    maxPovSize: number;
}>;
export type PersistedValidationData = $.Input<typeof $PersistedValidationData>;
/**
 * A message from a parachain to its Relay Chain.
 */
export declare const $UpwardMessage: $.Shape<`0x${string}`, `0x${string}`>;
export type UpwardMessage = $.Input<typeof $UpwardMessage>;
export declare const $UpwardMessages: $.Shape<`0x${string}`[], `0x${string}`[]>;
export type UpwardMessages = $.Input<typeof $UpwardMessages>;
/**
 * An HRMP message seen from the perspective of a sender.
 */
export declare const $OutboundHrmpMessage: $.Shape<{
    recipient: number;
    data: `0x${string}`;
}, {
    recipient: number;
    data: `0x${string}`;
}>;
export type OutboundHrmpMessage = $.Input<typeof $OutboundHrmpMessage>;
export declare const $HorizontalMessages: $.Shape<{
    recipient: number;
    data: `0x${string}`;
}[], {
    recipient: number;
    data: `0x${string}`;
}[]>;
export type HorizontalMessages = $.Input<typeof $HorizontalMessages>;
/**
 * Parachain validation code.
 */
export declare const $ValidationCode: $.Shape<`0x${string}`, `0x${string}`>;
export type ValidationCode = $.Input<typeof $ValidationCode>;
export declare const $CandidateCommitments: $.Shape<{
    upwardMessages: `0x${string}`[];
    horizontalMessages: {
        recipient: number;
        data: `0x${string}`;
    }[];
    newValidationCode: `0x${string}` | undefined;
    headData: `0x${string}`;
    processedDownwardMessages: number;
    hrmpWatermark: number;
}, {
    upwardMessages: `0x${string}`[];
    horizontalMessages: {
        recipient: number;
        data: `0x${string}`;
    }[];
    newValidationCode: `0x${string}` | undefined;
    headData: `0x${string}`;
    processedDownwardMessages: number;
    hrmpWatermark: number;
}>;
export type CandidateCommitments = $.Input<typeof $CandidateCommitments>;
/**
 * Simple index type with which we can count sessions.
 */
export declare const $SessionIndex: $.Shape<number, number>;
export type SessionIndex = $.Input<typeof $SessionIndex>;
/**
 * A candidate-receipt with commitments directly included.
 */
export declare const $CommittedCandidateReceipt: $.Shape<{
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitments: {
        upwardMessages: `0x${string}`[];
        horizontalMessages: {
            recipient: number;
            data: `0x${string}`;
        }[];
        newValidationCode: `0x${string}` | undefined;
        headData: `0x${string}`;
        processedDownwardMessages: number;
        hrmpWatermark: number;
    };
}, {
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitments: {
        upwardMessages: `0x${string}`[];
        horizontalMessages: {
            recipient: number;
            data: `0x${string}`;
        }[];
        newValidationCode: `0x${string}` | undefined;
        headData: `0x${string}`;
        processedDownwardMessages: number;
        hrmpWatermark: number;
    };
}>;
export type CommittedCandidateReceipt = $.Input<typeof $CommittedCandidateReceipt>;
/**
 * A candidate-receipt.
 */
export declare const $CandidateReceipt: $.Shape<{
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitmentsHash: `0x${string}`;
}, {
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitmentsHash: `0x${string}`;
}>;
export type CandidateReceipt = $.Input<typeof $CandidateReceipt>;
/**
 * The unique (during session) index of a core.
 */
export declare const $CoreIndex: $.Shape<number, number>;
export type CoreIndex = $.Input<typeof $CoreIndex>;
/**
 * An even concerning a candidate.
 */
export declare const $CandidateEvent: $.Shape<{
    type: "CandidateBacked";
    value: readonly [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number, number];
} | {
    type: "CandidateIncluded";
    value: readonly [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number, number];
} | {
    type: "CandidateTimedOut";
    value: readonly [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number];
}, {
    type: "CandidateBacked";
    value: [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number, number];
} | {
    type: "CandidateIncluded";
    value: [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number, number];
} | {
    type: "CandidateTimedOut";
    value: [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, `0x${string}`, number];
}>;
export type CandidateEvent = $.Input<typeof $CandidateEvent>;
/**
 * A message sent from the relay-chain down to a parachain.
 */
export declare const $DownwardMessage: $.Shape<`0x${string}`, `0x${string}`>;
export type DownwardMessage = $.Input<typeof $DownwardMessage>;
/**
 * A wrapped version of `DownwardMessage`. The difference is that it has attached the block number
 * when the message was sent.
 */
export declare const $InboundDownwardMessage: $.Shape<{
    sentAt: number;
    msg: `0x${string}`;
}, {
    sentAt: number;
    msg: `0x${string}`;
}>;
export type InboundDownwardMessage = $.Input<typeof $InboundDownwardMessage>;
export declare const $InboundHrmpMessage: $.Shape<{
    sentAt: number;
    data: `0x${string}`;
}, {
    sentAt: number;
    data: `0x${string}`;
}>;
export type InboundHrmpMessage = $.Input<typeof $InboundHrmpMessage>;
/**
 * Signature with which parachain validators sign blocks.
 *
 * For now we assert that parachain validator set is exactly equivalent to the authority set, and
 * so we define it to be the same type as `SessionKey`. In the future it may have different crypto.
 */
export declare const $ValidatorSignature: $.Shape<`0x${string}`, `0x${string}`>;
export type ValidatorSignature = $.Input<typeof $ValidatorSignature>;
/**
 * An either implicit or explicit attestation to the validity of a parachain
 * candidate.
 */
export declare const $ValidityAttestation: $.Shape<{
    type: "Implicit";
    value: `0x${string}`;
} | {
    type: "Explicit";
    value: `0x${string}`;
}, {
    type: "Implicit";
    value: `0x${string}`;
} | {
    type: "Explicit";
    value: `0x${string}`;
}>;
export type ValidityAttestation = $.Input<typeof $ValidityAttestation>;
/**
 * Different kinds of statements of validity on  a candidate.
 */
export declare const $ValidDisputeStatementKind: $.Shape<{
    type: "Explicit";
} | {
    type: "BackingSeconded";
    value: `0x${string}`;
} | {
    type: "BackingValid";
    value: `0x${string}`;
} | {
    type: "ApprovalChecking";
} | {
    type: "ApprovalCheckingMultipleCandidates";
    value: `0x${string}`[];
}, {
    type: "Explicit";
} | {
    type: "BackingSeconded";
    value: `0x${string}`;
} | {
    type: "BackingValid";
    value: `0x${string}`;
} | {
    type: "ApprovalChecking";
} | {
    type: "ApprovalCheckingMultipleCandidates";
    value: `0x${string}`[];
}>;
export type ValidDisputeStatementKind = $.Input<typeof $ValidDisputeStatementKind>;
/**
 * Different kinds of statements of invalidity on a candidate.
 */
export declare const $InvalidDisputeStatementKind: $.Shape<{
    type: "Explicit";
}, {
    type: "Explicit";
}>;
export type InvalidDisputeStatementKind = $.Input<typeof $InvalidDisputeStatementKind>;
/**
 * A statement about a candidate, to be used within the dispute resolution process.
 *
 * Statements are either in favor of the candidate's validity or against it.
 */
export declare const $DisputeStatement: $.Shape<{
    type: "Invalid";
    value: {
        type: "Explicit";
    };
} | {
    type: "Valid";
    value: {
        type: "Explicit";
    } | {
        type: "BackingSeconded";
        value: `0x${string}`;
    } | {
        type: "BackingValid";
        value: `0x${string}`;
    } | {
        type: "ApprovalChecking";
    } | {
        type: "ApprovalCheckingMultipleCandidates";
        value: `0x${string}`[];
    };
}, {
    type: "Invalid";
    value: {
        type: "Explicit";
    };
} | {
    type: "Valid";
    value: {
        type: "Explicit";
    } | {
        type: "BackingSeconded";
        value: `0x${string}`;
    } | {
        type: "BackingValid";
        value: `0x${string}`;
    } | {
        type: "ApprovalChecking";
    } | {
        type: "ApprovalCheckingMultipleCandidates";
        value: `0x${string}`[];
    };
}>;
export type DisputeStatement = $.Input<typeof $DisputeStatement>;
/**
 * A set of statements about a specific candidate.
 */
export declare const $DisputeStatementSet: $.Shape<{
    candidateHash: `0x${string}`;
    session: number;
    statements: (readonly [{
        type: "Invalid";
        value: {
            type: "Explicit";
        };
    } | {
        type: "Valid";
        value: {
            type: "Explicit";
        } | {
            type: "BackingSeconded";
            value: `0x${string}`;
        } | {
            type: "BackingValid";
            value: `0x${string}`;
        } | {
            type: "ApprovalChecking";
        } | {
            type: "ApprovalCheckingMultipleCandidates";
            value: `0x${string}`[];
        };
    }, number, `0x${string}`])[];
}, {
    candidateHash: `0x${string}`;
    session: number;
    statements: [{
        type: "Invalid";
        value: {
            type: "Explicit";
        };
    } | {
        type: "Valid";
        value: {
            type: "Explicit";
        } | {
            type: "BackingSeconded";
            value: `0x${string}`;
        } | {
            type: "BackingValid";
            value: `0x${string}`;
        } | {
            type: "ApprovalChecking";
        } | {
            type: "ApprovalCheckingMultipleCandidates";
            value: `0x${string}`[];
        };
    }, number, `0x${string}`][];
}>;
export type DisputeStatementSet = $.Input<typeof $DisputeStatementSet>;
/**
 * A set of dispute statements.
 */
export declare const $MultiDisputeStatementSet: $.Shape<{
    candidateHash: `0x${string}`;
    session: number;
    statements: (readonly [{
        type: "Invalid";
        value: {
            type: "Explicit";
        };
    } | {
        type: "Valid";
        value: {
            type: "Explicit";
        } | {
            type: "BackingSeconded";
            value: `0x${string}`;
        } | {
            type: "BackingValid";
            value: `0x${string}`;
        } | {
            type: "ApprovalChecking";
        } | {
            type: "ApprovalCheckingMultipleCandidates";
            value: `0x${string}`[];
        };
    }, number, `0x${string}`])[];
}[], {
    candidateHash: `0x${string}`;
    session: number;
    statements: [{
        type: "Invalid";
        value: {
            type: "Explicit";
        };
    } | {
        type: "Valid";
        value: {
            type: "Explicit";
        } | {
            type: "BackingSeconded";
            value: `0x${string}`;
        } | {
            type: "BackingValid";
            value: `0x${string}`;
        } | {
            type: "ApprovalChecking";
        } | {
            type: "ApprovalCheckingMultipleCandidates";
            value: `0x${string}`[];
        };
    }, number, `0x${string}`][];
}[]>;
export type MultiDisputeStatementSet = $.Input<typeof $MultiDisputeStatementSet>;
export declare const $ScrapedOnChainVotes: $.Shape<{
    session: number;
    backingValidatorsPerCandidate: (readonly [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, (readonly [number, {
        type: "Implicit";
        value: `0x${string}`;
    } | {
        type: "Explicit";
        value: `0x${string}`;
    }])[]])[];
    disputes: {
        candidateHash: `0x${string}`;
        session: number;
        statements: (readonly [{
            type: "Invalid";
            value: {
                type: "Explicit";
            };
        } | {
            type: "Valid";
            value: {
                type: "Explicit";
            } | {
                type: "BackingSeconded";
                value: `0x${string}`;
            } | {
                type: "BackingValid";
                value: `0x${string}`;
            } | {
                type: "ApprovalChecking";
            } | {
                type: "ApprovalCheckingMultipleCandidates";
                value: `0x${string}`[];
            };
        }, number, `0x${string}`])[];
    }[];
}, {
    session: number;
    backingValidatorsPerCandidate: [{
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitmentsHash: `0x${string}`;
    }, [number, {
        type: "Implicit";
        value: `0x${string}`;
    } | {
        type: "Explicit";
        value: `0x${string}`;
    }][]][];
    disputes: {
        candidateHash: `0x${string}`;
        session: number;
        statements: [{
            type: "Invalid";
            value: {
                type: "Explicit";
            };
        } | {
            type: "Valid";
            value: {
                type: "Explicit";
            } | {
                type: "BackingSeconded";
                value: `0x${string}`;
            } | {
                type: "BackingValid";
                value: `0x${string}`;
            } | {
                type: "ApprovalChecking";
            } | {
                type: "ApprovalCheckingMultipleCandidates";
                value: `0x${string}`[];
            };
        }, number, `0x${string}`][];
    }[];
}>;
export type ScrapedOnChainVotes = $.Input<typeof $ScrapedOnChainVotes>;
/**
 * Information about validator sets of a session.
 *
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/0ff3f4d3af0036bbae624011b720bfd5e93ce91b/polkadot/primitives/src/v6/mod.rs#L1714-L1774
 */
export declare const $SessionInfo: $.Shape<{
    activeValidatorIndices: number[];
    randomSeed: `0x${string}`;
    disputePeriod: number;
    validators: import("../generic/AccountId32.js").AccountId32Like[];
    discoveryKeys: import("../generic/AccountId32.js").AccountId32Like[];
    assignmentKeys: import("../generic/AccountId32.js").AccountId32Like[];
    validatorGroups: number[][];
    nCores: number;
    zerothDelayTrancheWidth: number;
    relayVrfModuloSamples: number;
    nDelayTranches: number;
    noShowSlots: number;
    neededApprovals: number;
}, {
    activeValidatorIndices: number[];
    randomSeed: `0x${string}`;
    disputePeriod: number;
    validators: import("../generic/AccountId32.js").AccountId32[];
    discoveryKeys: import("../generic/AccountId32.js").AccountId32[];
    assignmentKeys: import("../generic/AccountId32.js").AccountId32[];
    validatorGroups: number[][];
    nCores: number;
    zerothDelayTrancheWidth: number;
    relayVrfModuloSamples: number;
    nDelayTranches: number;
    noShowSlots: number;
    neededApprovals: number;
}>;
export type SessionInfo = $.Input<typeof $SessionInfo>;
/**
 * A statement from the specified validator whether the given validation code passes PVF
 * pre-checking or not anchored to the given session index.
 */
export declare const $PvfCheckStatement: $.Shape<{
    accept: boolean;
    subject: `0x${string}`;
    sessionIndex: number;
    validatorIndex: number;
}, {
    accept: boolean;
    subject: `0x${string}`;
    sessionIndex: number;
    validatorIndex: number;
}>;
export type PvfCheckStatement = $.Input<typeof $PvfCheckStatement>;
/**
 * The entire state of a dispute.
 */
export declare const $DisputeState: $.Shape<{
    validatorsFor: $.BitSequence;
    validatorsAgainst: $.BitSequence;
    start: number;
    concludedAt: number | undefined;
}, {
    validatorsFor: $.BitSequence;
    validatorsAgainst: $.BitSequence;
    start: number;
    concludedAt: number | undefined;
}>;
export type DisputeState = $.Input<typeof $DisputeState>;
/**
 * Type discriminator for PVF preparation
 */
export declare const $PvfPrepKind: $.Shape<"Precheck" | "Prepare", "Precheck" | "Prepare">;
export type PvfPrepKind = $.Input<typeof $PvfPrepKind>;
/**
 * Type discriminator for PVF execution.
 */
export declare const $PvfExecKind: $.Shape<"Backing" | "Approval", "Backing" | "Approval">;
export type PvfExecKind = $.Input<typeof $PvfExecKind>;
/**
 * The different executor parameters for changing the execution environment semantics.
 */
export declare const $ExecutorParam: $.Shape<{
    type: "MaxMemoryPages";
    value: number;
} | {
    type: "StackLogicalMax";
    value: number;
} | {
    type: "StackNativeMax";
    value: number;
} | {
    type: "PrecheckingMaxMemory";
    value: bigint;
} | {
    type: "PvfPrepTimeout";
    value: readonly ["Precheck" | "Prepare", bigint];
} | {
    type: "PvfExecTimeout";
    value: readonly ["Backing" | "Approval", bigint];
} | {
    type: "WasmExtBulkMemory";
}, {
    type: "MaxMemoryPages";
    value: number;
} | {
    type: "StackLogicalMax";
    value: number;
} | {
    type: "StackNativeMax";
    value: number;
} | {
    type: "PrecheckingMaxMemory";
    value: bigint;
} | {
    type: "PvfPrepTimeout";
    value: ["Precheck" | "Prepare", bigint];
} | {
    type: "PvfExecTimeout";
    value: ["Backing" | "Approval", bigint];
} | {
    type: "WasmExtBulkMemory";
}>;
export type ExecutorParam = $.Input<typeof $ExecutorParam>;
/**
 * # Deterministically serialized execution environment semantics
 * Represents an arbitrary semantics of an arbitrary execution environment, so should be kept as
 * abstract as possible.
 */
export declare const $ExecutorParams: $.Shape<({
    type: "MaxMemoryPages";
    value: number;
} | {
    type: "StackLogicalMax";
    value: number;
} | {
    type: "StackNativeMax";
    value: number;
} | {
    type: "PrecheckingMaxMemory";
    value: bigint;
} | {
    type: "PvfPrepTimeout";
    value: readonly ["Precheck" | "Prepare", bigint];
} | {
    type: "PvfExecTimeout";
    value: readonly ["Backing" | "Approval", bigint];
} | {
    type: "WasmExtBulkMemory";
})[], ({
    type: "MaxMemoryPages";
    value: number;
} | {
    type: "StackLogicalMax";
    value: number;
} | {
    type: "StackNativeMax";
    value: number;
} | {
    type: "PrecheckingMaxMemory";
    value: bigint;
} | {
    type: "PvfPrepTimeout";
    value: ["Precheck" | "Prepare", bigint];
} | {
    type: "PvfExecTimeout";
    value: ["Backing" | "Approval", bigint];
} | {
    type: "WasmExtBulkMemory";
})[]>;
export type ExecutorParams = $.Input<typeof $ExecutorParams>;
/**
 * The kind of the dispute offence.
 */
export declare const $SlashingOffenceKind: $.Shape<"ForInvalid" | "AgainstValid", "ForInvalid" | "AgainstValid">;
export type SlashingOffenceKind = $.Input<typeof $SlashingOffenceKind>;
/**
 * Slashes that are waiting to be applied once we have validator key
 * identification.
 */
export declare const $PendingSlashes: $.Shape<{
    keys: ReadonlyMap<number, import("../generic/AccountId32.js").AccountId32Like>;
    kind: "ForInvalid" | "AgainstValid";
}, {
    keys: $.ShapeMap<number, import("../generic/AccountId32.js").AccountId32>;
    kind: "ForInvalid" | "AgainstValid";
}>;
export type PendingSlashes = $.Input<typeof $PendingSlashes>;
/**
 * Timeslots should uniquely identify offences and are used for the offence
 * deduplication.
 */
export declare const $DisputesTimeSlot: $.Shape<{
    sessionIndex: number;
    candidateHash: `0x${string}`;
}, {
    sessionIndex: number;
    candidateHash: `0x${string}`;
}>;
export type DisputesTimeSlot = $.Input<typeof $DisputesTimeSlot>;
/**
 * We store most of the information about a lost dispute on chain. This struct
 * is required to identify and verify it.
 */
export declare const $DisputeProof: $.Shape<{
    timeSlot: {
        sessionIndex: number;
        candidateHash: `0x${string}`;
    };
    kind: "ForInvalid" | "AgainstValid";
    validatorIndex: number;
    validatorId: import("../generic/AccountId32.js").AccountId32Like;
}, {
    timeSlot: {
        sessionIndex: number;
        candidateHash: `0x${string}`;
    };
    kind: "ForInvalid" | "AgainstValid";
    validatorIndex: number;
    validatorId: import("../generic/AccountId32.js").AccountId32;
}>;
export type DisputeProof = $.Input<typeof $DisputeProof>;
/**
 * Constraints on inbound HRMP channels.
 */
export declare const $InboundHrmpLimitations: $.Shape<{
    valid_watermarks: number[];
}, {
    valid_watermarks: number[];
}>;
export type InboundHrmpLimitations = $.Input<typeof $InboundHrmpLimitations>;
/**
 * Constraints on outbound HRMP channels.
 */
export declare const $OutboundHrmpChannelLimitations: $.Shape<{
    bytesRemaining: number;
    messagesRemaining: number;
}, {
    bytesRemaining: number;
    messagesRemaining: number;
}>;
export type OutboundHrmpChannelLimitations = $.Input<typeof $OutboundHrmpChannelLimitations>;
/**
 * A possible upgrade restriction that prevents a parachain from performing an upgrade.
 */
export declare const $UpgradeRestriction: $.Shape<{
    type: "Present";
}, {
    type: "Present";
}>;
export type UpgradeRestriction = $.Input<typeof $UpgradeRestriction>;
/**
 * Constraints on the actions that can be taken by a new parachain
 * block. These limitations are implicitly associated with some particular
 * parachain, which should be apparent from usage.
 */
export declare const $Constraints: $.Shape<{
    minRelayParentNumber: number;
    maxPovSize: number;
    maxCodeSize: number;
    umpRemaining: number;
    umpRemainingBytes: number;
    maxUmpNumPerCandidate: number;
    dmpRemainingMessages: number[];
    hrmpInbound: {
        valid_watermarks: number[];
    };
    hrmpChannelsOut: (readonly [number, {
        bytesRemaining: number;
        messagesRemaining: number;
    }])[];
    maxHrmpNumPerCandidate: number;
    requiredParent: `0x${string}`;
    validationCodeHash: `0x${string}`;
    upgradeRestriction: {
        type: "Present";
    } | undefined;
    futureValidationCode: readonly [number, `0x${string}`] | undefined;
}, {
    minRelayParentNumber: number;
    maxPovSize: number;
    maxCodeSize: number;
    umpRemaining: number;
    umpRemainingBytes: number;
    maxUmpNumPerCandidate: number;
    dmpRemainingMessages: number[];
    hrmpInbound: {
        valid_watermarks: number[];
    };
    hrmpChannelsOut: [number, {
        bytesRemaining: number;
        messagesRemaining: number;
    }][];
    maxHrmpNumPerCandidate: number;
    requiredParent: `0x${string}`;
    validationCodeHash: `0x${string}`;
    upgradeRestriction: {
        type: "Present";
    } | undefined;
    futureValidationCode: [number, `0x${string}`] | undefined;
}>;
export type Constraints = $.Input<typeof $Constraints>;
/**
 * A candidate pending availability.
 */
export declare const $CandidatePendingAvailability: $.Shape<{
    candidateHash: `0x${string}`;
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitments: {
        upwardMessages: `0x${string}`[];
        horizontalMessages: {
            recipient: number;
            data: `0x${string}`;
        }[];
        newValidationCode: `0x${string}` | undefined;
        headData: `0x${string}`;
        processedDownwardMessages: number;
        hrmpWatermark: number;
    };
    relayParentNumber: number;
    maxPovSize: number;
}, {
    candidateHash: `0x${string}`;
    descriptor: {
        paraId: number;
        relayParent: `0x${string}`;
        collator: `0x${string}`;
        persistedValidationDataHash: `0x${string}`;
        povHash: `0x${string}`;
        erasureRoot: `0x${string}`;
        signature: `0x${string}`;
        paraHead: `0x${string}`;
        validationCodeHash: `0x${string}`;
    };
    commitments: {
        upwardMessages: `0x${string}`[];
        horizontalMessages: {
            recipient: number;
            data: `0x${string}`;
        }[];
        newValidationCode: `0x${string}` | undefined;
        headData: `0x${string}`;
        processedDownwardMessages: number;
        hrmpWatermark: number;
    };
    relayParentNumber: number;
    maxPovSize: number;
}>;
export type CandidatePendingAvailability = $.Input<typeof $CandidatePendingAvailability>;
export declare const $BackingState: $.Shape<{
    constraints: {
        minRelayParentNumber: number;
        maxPovSize: number;
        maxCodeSize: number;
        umpRemaining: number;
        umpRemainingBytes: number;
        maxUmpNumPerCandidate: number;
        dmpRemainingMessages: number[];
        hrmpInbound: {
            valid_watermarks: number[];
        };
        hrmpChannelsOut: (readonly [number, {
            bytesRemaining: number;
            messagesRemaining: number;
        }])[];
        maxHrmpNumPerCandidate: number;
        requiredParent: `0x${string}`;
        validationCodeHash: `0x${string}`;
        upgradeRestriction: {
            type: "Present";
        } | undefined;
        futureValidationCode: readonly [number, `0x${string}`] | undefined;
    };
    pendingAvailability: {
        candidateHash: `0x${string}`;
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitments: {
            upwardMessages: `0x${string}`[];
            horizontalMessages: {
                recipient: number;
                data: `0x${string}`;
            }[];
            newValidationCode: `0x${string}` | undefined;
            headData: `0x${string}`;
            processedDownwardMessages: number;
            hrmpWatermark: number;
        };
        relayParentNumber: number;
        maxPovSize: number;
    }[];
}, {
    constraints: {
        minRelayParentNumber: number;
        maxPovSize: number;
        maxCodeSize: number;
        umpRemaining: number;
        umpRemainingBytes: number;
        maxUmpNumPerCandidate: number;
        dmpRemainingMessages: number[];
        hrmpInbound: {
            valid_watermarks: number[];
        };
        hrmpChannelsOut: [number, {
            bytesRemaining: number;
            messagesRemaining: number;
        }][];
        maxHrmpNumPerCandidate: number;
        requiredParent: `0x${string}`;
        validationCodeHash: `0x${string}`;
        upgradeRestriction: {
            type: "Present";
        } | undefined;
        futureValidationCode: [number, `0x${string}`] | undefined;
    };
    pendingAvailability: {
        candidateHash: `0x${string}`;
        descriptor: {
            paraId: number;
            relayParent: `0x${string}`;
            collator: `0x${string}`;
            persistedValidationDataHash: `0x${string}`;
            povHash: `0x${string}`;
            erasureRoot: `0x${string}`;
            signature: `0x${string}`;
            paraHead: `0x${string}`;
            validationCodeHash: `0x${string}`;
        };
        commitments: {
            upwardMessages: `0x${string}`[];
            horizontalMessages: {
                recipient: number;
                data: `0x${string}`;
            }[];
            newValidationCode: `0x${string}` | undefined;
            headData: `0x${string}`;
            processedDownwardMessages: number;
            hrmpWatermark: number;
        };
        relayParentNumber: number;
        maxPovSize: number;
    }[];
}>;
export type BackingState = $.Input<typeof $BackingState>;
/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
export declare const $AsyncBackingParams: $.Shape<{
    maxCandidateDepth: number;
    allowedAncestryLen: number;
}, {
    maxCandidateDepth: number;
    allowedAncestryLen: number;
}>;
export type AsyncBackingParams = $.Input<typeof $AsyncBackingParams>;
/**
 * Bit indices in the `HostConfiguration.node_features` that correspond to different node features.
 */
export declare const $NodeFeatures: $.Shape<$.BitSequence, $.BitSequence>;
export type NodeFeatures = $.Input<typeof $NodeFeatures>;
