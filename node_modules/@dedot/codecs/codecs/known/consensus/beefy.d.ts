import * as $ from '@dedot/shape';
export declare const $BeefyPayloadId: $.Shape<`0x${string}`, `0x${string}`>;
export type BeefyPayloadId = $.Input<typeof $BeefyPayloadId>;
export declare const $Payload: $.Shape<(readonly [`0x${string}`, `0x${string}`])[], [`0x${string}`, `0x${string}`][]>;
export type Payload = $.Input<typeof $Payload>;
export declare const $Commitment: $.Shape<{
    payload: (readonly [`0x${string}`, `0x${string}`])[];
    blockNumber: number;
    validatorSetId: bigint;
}, {
    payload: [`0x${string}`, `0x${string}`][];
    blockNumber: number;
    validatorSetId: bigint;
}>;
export type Commitment = $.Input<typeof $Commitment>;
export declare const $CompactSignedCommitment: $.Shape<{
    commitment: {
        payload: (readonly [`0x${string}`, `0x${string}`])[];
        blockNumber: number;
        validatorSetId: bigint;
    };
    signatures_from: `0x${string}`;
    validator_set_len: number;
    signatures_compact: `0x${string}`[];
}, {
    commitment: {
        payload: [`0x${string}`, `0x${string}`][];
        blockNumber: number;
        validatorSetId: bigint;
    };
    signatures_from: `0x${string}`;
    validator_set_len: number;
    signatures_compact: `0x${string}`[];
}>;
export type CompactSignedCommitment = $.Input<typeof $CompactSignedCommitment>;
export declare const $VersionedFinalityProof: $.Shape<{
    type: "V1";
    value: {
        commitment: {
            payload: (readonly [`0x${string}`, `0x${string}`])[];
            blockNumber: number;
            validatorSetId: bigint;
        };
        signatures_from: `0x${string}`;
        validator_set_len: number;
        signatures_compact: `0x${string}`[];
    };
}, {
    type: "V1";
    value: {
        commitment: {
            payload: [`0x${string}`, `0x${string}`][];
            blockNumber: number;
            validatorSetId: bigint;
        };
        signatures_from: `0x${string}`;
        validator_set_len: number;
        signatures_compact: `0x${string}`[];
    };
}>;
export type VersionedFinalityProof = $.Input<typeof $VersionedFinalityProof>;
/**
 * A typedef for validator set id.
 */
export declare const $ValidatorSetId: $.Shape<bigint, bigint>;
export type ValidatorSetId = $.Input<typeof $ValidatorSetId>;
/**
 * A set of BEEFY authorities, a.k.a. validators.
 */
export declare const $ValidatorSet: $.Shape<{
    validators: import("../../generic/AccountId32.js").AccountId32Like[];
    id: bigint;
}, {
    validators: import("../../generic/AccountId32.js").AccountId32[];
    id: bigint;
}>;
export type ValidatorSet = $.Input<typeof $ValidatorSet>;
/**
 * BEEFY vote message.
 *
 * A vote message is a direct vote created by a BEEFY node on every voting round
 * and is gossiped to its peers.
 */
export declare const $VoteMessage: $.Shape<{
    commitment: {
        payload: (readonly [`0x${string}`, `0x${string}`])[];
        blockNumber: number;
        validatorSetId: bigint;
    };
    id: import("../../generic/AccountId32.js").AccountId32Like;
    signature: `0x${string}`;
}, {
    commitment: {
        payload: [`0x${string}`, `0x${string}`][];
        blockNumber: number;
        validatorSetId: bigint;
    };
    id: import("../../generic/AccountId32.js").AccountId32;
    signature: `0x${string}`;
}>;
export type VoteMessage = $.Input<typeof $VoteMessage>;
/**
 * Proof of voter misbehavior on a given set id. Misbehavior/equivocation in
 * BEEFY happens when a voter votes on the same round/block for different payloads.
 * Proving is achieved by collecting the signed commitments of conflicting votes.
 */
export declare const $BeefyEquivocationProof: $.Shape<{
    first: {
        commitment: {
            payload: (readonly [`0x${string}`, `0x${string}`])[];
            blockNumber: number;
            validatorSetId: bigint;
        };
        id: import("../../generic/AccountId32.js").AccountId32Like;
        signature: `0x${string}`;
    };
    second: {
        commitment: {
            payload: (readonly [`0x${string}`, `0x${string}`])[];
            blockNumber: number;
            validatorSetId: bigint;
        };
        id: import("../../generic/AccountId32.js").AccountId32Like;
        signature: `0x${string}`;
    };
}, {
    first: {
        commitment: {
            payload: [`0x${string}`, `0x${string}`][];
            blockNumber: number;
            validatorSetId: bigint;
        };
        id: import("../../generic/AccountId32.js").AccountId32;
        signature: `0x${string}`;
    };
    second: {
        commitment: {
            payload: [`0x${string}`, `0x${string}`][];
            blockNumber: number;
            validatorSetId: bigint;
        };
        id: import("../../generic/AccountId32.js").AccountId32;
        signature: `0x${string}`;
    };
}>;
export type BeefyEquivocationProof = $.Input<typeof $BeefyEquivocationProof>;
/**
 * Details of a BEEFY authority set.
 */
export declare const $BeefyAuthoritySet: $.Shape<{
    id: bigint;
    len: number;
    keysetCommitment: `0x${string}`;
}, {
    id: bigint;
    len: number;
    keysetCommitment: `0x${string}`;
}>;
export type BeefyAuthoritySet = $.Input<typeof $BeefyAuthoritySet>;
/**
 * Details of the next BEEFY authority set.
 */
export declare const $BeefyNextAuthoritySet: $.Shape<{
    id: bigint;
    len: number;
    keysetCommitment: `0x${string}`;
}, {
    id: bigint;
    len: number;
    keysetCommitment: `0x${string}`;
}>;
export type BeefyNextAuthoritySet = $.Input<typeof $BeefyNextAuthoritySet>;
