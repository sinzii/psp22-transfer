"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeRegistry = void 0;
const $ = __importStar(require("@dedot/shape"));
const utils_1 = require("@dedot/utils");
const index_js_1 = require("../codecs/index.js");
const KNOWN_CODECS = {
    'sp_core::crypto::AccountId32': index_js_1.$AccountId32,
    'sp_runtime::generic::era::Era': index_js_1.$Era,
    'sp_runtime::multiaddress::MultiAddress': index_js_1.$MultiAddress,
    'fp_account::AccountId20': index_js_1.$AccountId20,
    'account::AccountId20': index_js_1.$AccountId20,
    'polkadot_runtime_common::claims::EthereumAddress': index_js_1.$EthereumAddress,
    'sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic': index_js_1.$UncheckedExtrinsic,
    'pallet_identity::types::Data': index_js_1.$Data,
    'sp_runtime::generic::digest::Digest': index_js_1.$Digest,
    'sp_runtime::generic::digest::DigestItem': index_js_1.$DigestItem,
    'sp_runtime::generic::header::Header': index_js_1.$Header,
    'ink_primitives::types::Hash': index_js_1.$Hash,
    'ink_primitives::types::AccountId': index_js_1.$AccountId32,
};
class TypeRegistry {
    types;
    #cache;
    constructor(types) {
        if (Array.isArray(types)) {
            this.types = types.reduce((o, one) => {
                o[one.id] = one;
                return o;
            }, {});
        }
        else {
            this.types = types;
        }
        this.#cache = new Map();
    }
    findType(typeId) {
        const type = this.types[typeId];
        if (!type) {
            throw new Error(`Cannot find portable type for id: ${typeId}`);
        }
        return type;
    }
    findCodec(typeId) {
        const typeDef = this.findType(typeId);
        if (typeDef && typeDef.path.length > 0) {
            try {
                const fullPath = typeDef.path.join('::');
                if (!!KNOWN_CODECS[fullPath]) {
                    // TODO Check codec structure matches with corresponding portable codec
                    // Preparing for customizing primitive codecs
                    return KNOWN_CODECS[fullPath];
                }
            }
            catch (e) {
                // ignore
            }
        }
        if (this.#cache.has(typeId)) {
            return this.#cache.get(typeId);
        }
        // A placeholder codec for typeId so if this typeId is used in the `#createCodec`
        // the recursion will be resolved
        this.#cache.set(typeId, $.deferred(() => this.#cache.get(typeId) || index_js_1.$RawBytes));
        const $codec = this.#createCodec(typeId);
        this.#cache.set(typeId, $codec);
        return $codec;
    }
    // Create codec for a portable type from its type definition
    // TODO refactor this!
    #createCodec = (typeId) => {
        const def = this.types[typeId];
        if (!def) {
            throw new Error(`Type id not found ${typeId}`);
        }
        const { typeDef, path } = def;
        const { type, value } = typeDef;
        if (type === 'Struct') {
            const { fields } = value;
            if (fields.length === 0) {
                return $.Struct({});
            }
            else if (fields[0].name === undefined) {
                if (fields.length === 1) {
                    return this.findCodec(fields[0].typeId);
                }
                else {
                    return $.Tuple(...fields.map((x) => this.findCodec(x.typeId)));
                }
            }
            else {
                return $.Struct(fields.reduce((o, field) => ({
                    ...o,
                    [(0, utils_1.normalizeName)(field.name)]: this.findCodec(field.typeId),
                }), {}));
            }
        }
        else if (type === 'Tuple') {
            const { fields } = value;
            if (fields.length === 0) {
                return $.Tuple();
            }
            else if (fields.length === 1) {
                // wrapper
                return this.findCodec(fields[0]);
            }
            else {
                return $.Tuple(...fields.map((x) => this.findCodec(x)));
            }
        }
        else if (type === 'Enum') {
            const { members } = value;
            // Handle optional field
            if (path.join('::') === 'Option') {
                const some = members.find((one) => one.name === 'Some');
                if (some) {
                    const $codec = this.findCodec(some.fields[0].typeId);
                    if ($codec.metadata[0].name === '$.bool') {
                        return $.optionBool;
                    }
                    else {
                        return $.Option($codec);
                    }
                }
            }
            else if (path.join('::') === 'Result') {
                const ok = members.find((one) => one.name === 'Ok');
                const err = members.find((one) => one.name === 'Err');
                if (ok && err) {
                    const $OkCodec = this.findCodec(ok.fields[0].typeId);
                    const $ErrCodec = this.findCodec(err.fields[0].typeId);
                    return $.Result($OkCodec, $ErrCodec);
                }
            }
            if (members.length === 0) {
                return $.Null;
            }
            else if (members.every((x) => x.fields.length === 0)) {
                const enumMembers = {};
                for (const { index, name } of members) {
                    enumMembers[index] = name;
                }
                return $.FlatEnum(enumMembers);
            }
            else {
                const enumMembers = {};
                for (const { fields, name, index } of members) {
                    const keyName = (0, utils_1.stringPascalCase)(name);
                    if (fields.length === 0) {
                        enumMembers[keyName] = { index };
                    }
                    else if (fields[0].name === undefined) {
                        const $value = fields.length === 1
                            ? this.findCodec(fields[0].typeId)
                            : $.Tuple(...fields.map((f) => this.findCodec(f.typeId)));
                        enumMembers[keyName] = { index, value: $value };
                    }
                    else {
                        enumMembers[keyName] = {
                            index,
                            value: $.Struct(fields.reduce((o, field) => ({
                                ...o,
                                [(0, utils_1.normalizeName)(field.name)]: this.findCodec(field.typeId),
                            }), {})),
                        };
                    }
                }
                return $.Enum(enumMembers, this.getEnumOptions(typeId));
            }
        }
        else if (type === 'Sequence') {
            const $inner = this.findCodec(typeDef.value.typeParam);
            if ($inner === $.u8) {
                return index_js_1.$Bytes;
            }
            else {
                return $.Vec($inner);
            }
        }
        else if (type === 'SizedVec') {
            const $inner = this.findCodec(typeDef.value.typeParam);
            if ($inner === $.u8) {
                return $.FixedHex(typeDef.value.len);
            }
            else {
                return $.SizedVec($inner, typeDef.value.len);
            }
        }
        else if (type === 'Primitive') {
            const kind = typeDef.value.kind;
            if (kind === 'char') {
                return $.str;
            }
            const $codec = $[kind];
            if (!$codec) {
                throw new Error(`Invalid primitive kind: ${kind}`);
            }
            return $codec;
        }
        else if (type === 'Compact') {
            return $.compact(this.findCodec(typeDef.value.typeParam));
        }
        else if (type === 'BitSequence') {
            return $.bitSequence;
        }
        throw Error(`Not support yet! ${JSON.stringify(def, null, 2)}`);
    };
    getEnumOptions(_typeId) {
        return {
            tagKey: 'type',
            valueKey: 'value',
        };
    }
}
exports.TypeRegistry = TypeRegistry;
