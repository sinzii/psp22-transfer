"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$BeefyNextAuthoritySet = exports.$BeefyAuthoritySet = exports.$BeefyEquivocationProof = exports.$VoteMessage = exports.$ValidatorSet = exports.$ValidatorSetId = exports.$VersionedFinalityProof = exports.$CompactSignedCommitment = exports.$Commitment = exports.$Payload = exports.$BeefyPayloadId = void 0;
const $ = __importStar(require("@dedot/shape"));
const index_js_1 = require("../../generic/index.js");
const primitives_js_1 = require("../primitives.js");
exports.$BeefyPayloadId = $.FixedHex(2);
exports.$Payload = $.Vec($.Tuple(exports.$BeefyPayloadId, $.PrefixedHex));
exports.$Commitment = $.Struct({
    //  A collection of payloads to be signed, see [`Payload`] for details.
    //
    // One of the payloads should be some form of cumulative representation of the chain (think
    // MMR root hash). Additionally one of the payloads should also contain some details that
    // allow the light client to verify next validator set. The protocol does not enforce any
    // particular format of this data, nor how often it should be present in commitments, however
    // the light client has to be provided with full validator set whenever it performs the
    // transition (i.e. importing first block with
    // [validator_set_id](Commitment::validator_set_id) incremented).
    payload: exports.$Payload,
    // Finalized block number this commitment is for.
    //
    // GRANDPA validators agree on a block they create a commitment for and start collecting
    // signatures. This process is called a round.
    // There might be multiple rounds in progress (depending on the block choice rule), however
    // since the payload is supposed to be cumulative, it is not required to import all
    // commitments.
    // BEEFY light client is expected to import at least one commitment per epoch,
    // but is free to import as many as it requires.
    blockNumber: $.u32,
    // BEEFY validator set supposed to sign this commitment.
    //
    // Validator set is changing once per epoch. The Light Client must be provided by details
    // about the validator set whenever it's importing first commitment with a new
    // `validator_set_id`. Validator set data MUST be verifiable, for instance using
    // [payload](Commitment::payload) information.
    validatorSetId: $.u64,
});
exports.$CompactSignedCommitment = $.Struct({
    // The commitment, unchanged compared to regular [`SignedCommitment`].
    commitment: exports.$Commitment,
    // A bitfield representing presence of a signature coming from a validator at some index.
    //
    // The bit at index `0` is set to `1` in case we have a signature coming from a validator at
    // index `0` in the original validator set. In case the [`SignedCommitment`] does not
    // contain that signature the `bit` will be set to `0`. Bits are packed into `Vec<u8>`
    signatures_from: $.PrefixedHex,
    // Number of validators in the Validator Set and hence number of significant bits in the
    // [`signatures_from`] collection.
    //
    // Note this might be smaller than the size of `signatures_compact` in case some signatures
    // are missing.
    validator_set_len: $.u32,
    // A `Vec` containing all `Signature`s present in the original [`SignedCommitment`].
    //
    // Note that in order to associate a `Signature` from this `Vec` with a validator, one needs
    // to look at the `signatures_from` bitfield, since some validators might have not produced a
    // signature.
    signatures_compact: $.Vec($.FixedHex(65)),
});
/*
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/3fef703e3027a60cbeba8a72369554c6dabfb689/substrate/primitives/consensus/beefy/src/commitment.rs#L237-L242
 */
exports.$VersionedFinalityProof = $.Enum({
    // SignedCommitment using a custom [Encode] and [Decode] implementations from CompactSignedCommitment
    // Current active version
    V1: { index: 1, value: exports.$CompactSignedCommitment },
});
/**
 * A typedef for validator set id.
 */
exports.$ValidatorSetId = $.u64;
/**
 * A set of BEEFY authorities, a.k.a. validators.
 */
exports.$ValidatorSet = $.Struct({
    /// Public keys of the validator set elements
    validators: $.Vec(index_js_1.$AccountId32),
    /// Identifier of the validator set
    id: exports.$ValidatorSetId,
});
/**
 * BEEFY vote message.
 *
 * A vote message is a direct vote created by a BEEFY node on every voting round
 * and is gossiped to its peers.
 */
exports.$VoteMessage = $.Struct({
    /// Commit to information extracted from a finalized block
    commitment: exports.$Commitment,
    /// Node authority id
    id: index_js_1.$AccountId32,
    /// Node signature
    signature: primitives_js_1.$H512,
});
/**
 * Proof of voter misbehavior on a given set id. Misbehavior/equivocation in
 * BEEFY happens when a voter votes on the same round/block for different payloads.
 * Proving is achieved by collecting the signed commitments of conflicting votes.
 */
exports.$BeefyEquivocationProof = $.Struct({
    /// The first vote in the equivocation.
    first: exports.$VoteMessage,
    /// The second vote in the equivocation.
    second: exports.$VoteMessage,
});
/**
 * Details of a BEEFY authority set.
 */
exports.$BeefyAuthoritySet = $.Struct({
    /// Id of the set.
    ///
    /// Id is required to correlate BEEFY signed commitments with the validator set.
    /// Light Client can easily verify that the commitment witness it is getting is
    /// produced by the latest validator set.
    id: exports.$ValidatorSetId,
    /// Number of validators in the set.
    ///
    /// Some BEEFY Light Clients may use an interactive protocol to verify only a subset
    /// of signatures. We put set length here, so that these clients can verify the minimal
    /// number of required signatures.
    len: $.u32,
    /// Commitment(s) to BEEFY AuthorityIds.
    ///
    /// This is used by Light Clients to confirm that the commitments are signed by the correct
    /// validator set. Light Clients using interactive protocol, might verify only subset of
    /// signatures, hence don't require the full list here (will receive inclusion proofs).
    ///
    /// This could be Merkle Root Hash built from BEEFY ECDSA public keys and/or
    /// polynomial commitment to the polynomial interpolating BLS public keys
    /// which is used by APK proof based light clients to verify the validity
    /// of aggregated BLS keys using APK proofs.
    /// Multiple commitments can be tupled together.
    keysetCommitment: primitives_js_1.$H256,
});
/**
 * Details of the next BEEFY authority set.
 */
exports.$BeefyNextAuthoritySet = exports.$BeefyAuthoritySet;
