"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$DisputeProof = exports.$DisputesTimeSlot = exports.$PendingSlashes = exports.$SlashingOffenceKind = exports.$ExecutorParams = exports.$ExecutorParam = exports.$PvfExecKind = exports.$PvfPrepKind = exports.$DisputeState = exports.$PvfCheckStatement = exports.$SessionInfo = exports.$ScrapedOnChainVotes = exports.$MultiDisputeStatementSet = exports.$DisputeStatementSet = exports.$DisputeStatement = exports.$InvalidDisputeStatementKind = exports.$ValidDisputeStatementKind = exports.$ValidityAttestation = exports.$ValidatorSignature = exports.$InboundHrmpMessage = exports.$InboundDownwardMessage = exports.$DownwardMessage = exports.$CandidateEvent = exports.$CoreIndex = exports.$CandidateReceipt = exports.$CommittedCandidateReceipt = exports.$SessionIndex = exports.$CandidateCommitments = exports.$ValidationCode = exports.$HorizontalMessages = exports.$OutboundHrmpMessage = exports.$UpwardMessages = exports.$UpwardMessage = exports.$PersistedValidationData = exports.$HeadData = exports.$OccupiedCoreAssumption = exports.$CoreState = exports.$OccupiedCore = exports.$CandidateDescriptor = exports.$ValidationCodeHash = exports.$CollatorSignature = exports.$CandidateHash = exports.$GroupIndex = exports.$ScheduledCore = exports.$CollatorId = exports.$ParaId = exports.$GroupRotationInfo = exports.$ParaValidatorIndex = exports.$ValidatorId = exports.$ApprovalVotingParams = void 0;
exports.$NodeFeatures = exports.$AsyncBackingParams = exports.$BackingState = exports.$CandidatePendingAvailability = exports.$Constraints = exports.$UpgradeRestriction = exports.$OutboundHrmpChannelLimitations = exports.$InboundHrmpLimitations = void 0;
const $ = __importStar(require("@dedot/shape"));
const index_js_1 = require("../generic/index.js");
const primitives_js_1 = require("./primitives.js");
/**
 * Approval voting configuration parameters
 */
exports.$ApprovalVotingParams = $.Struct({
    // The maximum number of candidates `approval-voting` can vote for with
    // a single signatures.
    //
    // Setting it to 1, means we send the approval as soon as we have it available.
    maxApprovalCoalesceCount: $.u32,
});
/**
 * Identity that parachain validators use when signing validation messages.
 */
exports.$ValidatorId = index_js_1.$AccountId32;
/**
 * Index of the validator is used as a lightweight replacement of the `ValidatorId` when
 * appropriate.
 */
exports.$ParaValidatorIndex = $.u32;
/**
 * A helper data-type for tracking validator-group rotations.
 */
exports.$GroupRotationInfo = $.Struct({
    // The block number where the session started.
    sessionStartBlock: index_js_1.$BlockNumber,
    // How often groups rotate. 0 means never.
    groupRotationFrequency: index_js_1.$BlockNumber,
    // The current block number.
    now: index_js_1.$BlockNumber,
});
/**
 * Unique identifier of a parachain.
 */
exports.$ParaId = $.u32;
/**
 * Identity that collators use.
 */
exports.$CollatorId = primitives_js_1.$H256;
/**
 * Information about a core which is currently occupied.
 */
exports.$ScheduledCore = $.Struct({
    // The ID of a para scheduled.
    paraId: exports.$ParaId,
    // DEPRECATED: see: <https://github.com/paritytech/polkadot/issues/7575>
    //
    // Will be removed in a future version.
    collator: $.Option(exports.$CollatorId),
});
/**
 * The unique (during session) index of a validator group.
 */
exports.$GroupIndex = $.u32;
/**
 * Unit type wrapper around [`type@Hash`] that represents a candidate hash.
 *
 * This type is produced by `CandidateReceipt::hash`.
 *
 * This type makes it easy to enforce that a hash is a candidate hash on the type level.
 */
exports.$CandidateHash = index_js_1.$Hash;
/**
 * Signature on candidate's block data by a collator.
 */
exports.$CollatorSignature = primitives_js_1.$H512;
/**
 * Unit type wrapper around [`type@Hash`] that represents the blake2-256 hash
 * of validation code in particular.
 *
 * This type is produced by [`ValidationCode::hash`].
 *
 * This type makes it easy to enforce that a hash is a validation code hash on the type level.
 */
exports.$ValidationCodeHash = index_js_1.$Hash;
/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
exports.$CandidateDescriptor = $.Struct({
    // The ID of the para this is a candidate for.
    paraId: exports.$ParaId,
    // The hash of the relay-chain block this is executed in the context of.
    relayParent: index_js_1.$Hash,
    // The collator's sr25519 public key.
    collator: exports.$CollatorId,
    // The blake2-256 hash of the persisted validation data. This is extra data derived from
    // relay-chain state which may vary based on bitfields included before the candidate.
    // Thus it cannot be derived entirely from the relay-parent.
    persistedValidationDataHash: index_js_1.$Hash,
    // The blake2-256 hash of the PoV.
    povHash: index_js_1.$Hash,
    // The root of a block's erasure encoding Merkle tree.
    erasureRoot: index_js_1.$Hash,
    // Signature on blake2-256 of components of this receipt:
    // The parachain index, the relay parent, the validation data hash, and the `pov_hash`.
    signature: exports.$CollatorSignature,
    // Hash of the para header that is being generated by this candidate.
    paraHead: index_js_1.$Hash,
    // The blake2-256 hash of the validation code bytes.
    validationCodeHash: exports.$ValidationCodeHash,
});
/**
 * Information about a core which is currently occupied.
 */
exports.$OccupiedCore = $.Struct({
    // If this core is freed by availability, this is the assignment that is next up on this
    // core, if any. None if there is nothing queued for this core.
    nextUpOnAvailable: $.Option(exports.$ScheduledCore),
    // The relay-chain block number this began occupying the core at.
    occupiedSince: index_js_1.$BlockNumber,
    // The relay-chain block this will time-out at, if any.
    timeOutAt: index_js_1.$BlockNumber,
    // If this core is freed by being timed-out, this is the assignment that is next up on this
    // core. None if there is nothing queued for this core or there is no possibility of timing
    // out.
    nextUpOnTimeOut: $.Option(exports.$ScheduledCore),
    // A bitfield with 1 bit for each validator in the set. `1` bits mean that the corresponding
    // validators has attested to availability on-chain. A 2/3+ majority of `1` bits means that
    // this will be available.
    availability: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>,
    // The group assigned to distribute availability pieces of this candidate.
    groupResponsible: exports.$GroupIndex,
    // The hash of the candidate occupying the core.
    candidateHash: exports.$CandidateHash,
    // The descriptor of the candidate occupying the core.
    candidateDescriptor: exports.$CandidateDescriptor,
});
/**
 * The state of a particular availability core.
 */
exports.$CoreState = $.Enum({
    // The core is currently occupied.
    Occupied: exports.$OccupiedCore,
    // The core is currently free, with a para scheduled and given the opportunity
    // to occupy.
    //
    // If a particular Collator is required to author this block, that is also present in this
    // variant.
    Scheduled: exports.$ScheduledCore,
    // The core is currently free and there is nothing scheduled. This can be the case for
    // parathread cores when there are no parathread blocks queued. Parachain cores will never be
    // left idle.
    Free: null,
});
/**
 * An assumption being made about the state of an occupied core.
 */
exports.$OccupiedCoreAssumption = $.FlatEnum([
    // The candidate occupying the core was made available and included to free the core.
    'Included',
    // The candidate occupying the core timed out and freed the core without advancing the para.
    'TimedOut',
    // The core was not occupied to begin with.
    'Free',
]);
/**
 * Parachain head data included in the chain.
 */
exports.$HeadData = $.PrefixedHex;
/**
 * The validation data provides information about how to create the inputs for validation of a
 * candidate. This information is derived from the chain state and will vary from para to para,
 * although some fields may be the same for every para.
 *
 * Since this data is used to form inputs to the validation function, it needs to be persisted by
 * the availability system to avoid dependence on availability of the relay-chain state.
 *
 * Furthermore, the validation data acts as a way to authorize the additional data the collator
 * needs to pass to the validation function. For example, the validation function can check whether
 * the incoming messages (e.g. downward messages) were actually sent by using the data provided in
 * the validation data using so called MQC heads.
 *
 * Since the commitments of the validation function are checked by the relay-chain, secondary
 * checkers can rely on the invariant that the relay-chain only includes para-blocks for which
 * these checks have already been done. As such, there is no need for the validation data used to
 * inform validators and collators about the checks the relay-chain will perform to be persisted by
 * the availability system.
 *
 * The `PersistedValidationData` should be relatively lightweight primarily because it is
 * constructed during inclusion for each candidate and therefore lies on the critical path of
 * inclusion.
 */
exports.$PersistedValidationData = $.Struct({
    // The parent head-data.
    parentHead: exports.$HeadData,
    // The relay-chain block number this is in the context of.
    relayParentNumber: index_js_1.$BlockNumber,
    // The relay-chain block storage root this is in the context of.
    relayParentStorageRoot: index_js_1.$Hash,
    // The maximum legal size of a POV block, in bytes.
    maxPovSize: $.u32,
});
/**
 * A message from a parachain to its Relay Chain.
 */
exports.$UpwardMessage = $.PrefixedHex;
exports.$UpwardMessages = $.Vec(exports.$UpwardMessage);
/**
 * An HRMP message seen from the perspective of a sender.
 */
exports.$OutboundHrmpMessage = $.Struct({
    // The para that will get this message in its downward message queue.
    recipient: exports.$ParaId,
    // The message payload.
    data: $.PrefixedHex,
});
exports.$HorizontalMessages = $.Vec(exports.$OutboundHrmpMessage);
/**
 * Parachain validation code.
 */
exports.$ValidationCode = $.PrefixedHex;
exports.$CandidateCommitments = $.Struct({
    // Messages destined to be interpreted by the Relay chain itself.
    upwardMessages: exports.$UpwardMessages,
    // Horizontal messages sent by the parachain.
    horizontalMessages: exports.$HorizontalMessages,
    // New validation code.
    newValidationCode: $.Option(exports.$ValidationCode),
    // The head-data produced as a result of execution.
    headData: exports.$HeadData,
    // The number of messages processed from the DMQ.
    processedDownwardMessages: $.u32,
    // The mark which specifies the block number up to which all inbound HRMP messages are
    // processed.
    hrmpWatermark: index_js_1.$BlockNumber,
});
/**
 * Simple index type with which we can count sessions.
 */
exports.$SessionIndex = $.u32;
/**
 * A candidate-receipt with commitments directly included.
 */
exports.$CommittedCandidateReceipt = $.Struct({
    // The descriptor of the candidate.
    descriptor: exports.$CandidateDescriptor,
    // The commitments of the candidate receipt.
    commitments: exports.$CandidateCommitments,
});
/**
 * A candidate-receipt.
 */
exports.$CandidateReceipt = $.Struct({
    // The descriptor of the candidate.
    descriptor: exports.$CandidateDescriptor,
    // The hash of the encoded commitments made as a result of candidate execution.
    commitmentsHash: index_js_1.$Hash,
});
/**
 * The unique (during session) index of a core.
 */
exports.$CoreIndex = $.u32;
/**
 * An even concerning a candidate.
 */
exports.$CandidateEvent = $.Enum({
    // This candidate receipt was backed in the most recent block.
    // This includes the core index the candidate is now occupying.
    CandidateBacked: $.Tuple(exports.$CandidateReceipt, exports.$HeadData, exports.$CoreIndex, exports.$GroupIndex),
    // This candidate receipt was included and became a parablock at the most recent block.
    // This includes the core index the candidate was occupying as well as the group responsible
    // for backing the candidate.
    CandidateIncluded: $.Tuple(exports.$CandidateReceipt, exports.$HeadData, exports.$CoreIndex, exports.$GroupIndex),
    // This candidate receipt was not made available in time and timed out.
    // This includes the core index the candidate was occupying.
    CandidateTimedOut: $.Tuple(exports.$CandidateReceipt, exports.$HeadData, exports.$CoreIndex),
});
/**
 * A message sent from the relay-chain down to a parachain.
 */
exports.$DownwardMessage = $.PrefixedHex;
/**
 * A wrapped version of `DownwardMessage`. The difference is that it has attached the block number
 * when the message was sent.
 */
exports.$InboundDownwardMessage = $.Struct({
    // The block number at which these messages were put into the downward message queue.
    sentAt: index_js_1.$BlockNumber,
    // The actual downward message to processes.
    msg: exports.$DownwardMessage,
});
exports.$InboundHrmpMessage = $.Struct({
    // The block number at which this message was sent.
    // Specifically, it is the block number at which the candidate that sends this message was
    // enacted.
    sentAt: index_js_1.$BlockNumber,
    // The message payload.
    data: $.PrefixedHex,
});
/**
 * Signature with which parachain validators sign blocks.
 *
 * For now we assert that parachain validator set is exactly equivalent to the authority set, and
 * so we define it to be the same type as `SessionKey`. In the future it may have different crypto.
 */
exports.$ValidatorSignature = primitives_js_1.$H512;
/**
 * An either implicit or explicit attestation to the validity of a parachain
 * candidate.
 */
exports.$ValidityAttestation = $.Enum({
    // Implicit validity attestation by issuing.
    // This corresponds to issuance of a `Candidate` statement.
    Implicit: { index: 1, value: exports.$ValidatorSignature },
    // An explicit attestation. This corresponds to issuance of a
    // `Valid` statement.
    Explicit: { index: 2, value: exports.$ValidatorSignature },
});
/**
 * Different kinds of statements of validity on  a candidate.
 */
exports.$ValidDisputeStatementKind = $.Enum({
    // An explicit statement issued as part of a dispute.
    Explicit: null,
    // A seconded statement on a candidate from the backing phase.
    BackingSeconded: index_js_1.$Hash,
    // A valid statement on a candidate from the backing phase.
    BackingValid: index_js_1.$Hash,
    // An approval vote from the approval checking phase.
    ApprovalChecking: null,
    // An approval vote from the new version.
    // We can't create this version untill all nodes
    // have been updated to support it and max_approval_coalesce_count
    // is set to more than 1.
    ApprovalCheckingMultipleCandidates: $.Vec(exports.$CandidateHash),
});
/**
 * Different kinds of statements of invalidity on a candidate.
 */
exports.$InvalidDisputeStatementKind = $.Enum({
    // An explicit statement issued as part of a dispute.
    Explicit: null,
});
/**
 * A statement about a candidate, to be used within the dispute resolution process.
 *
 * Statements are either in favor of the candidate's validity or against it.
 */
exports.$DisputeStatement = $.Enum({
    // A valid statement, of the given kind.
    Valid: exports.$ValidDisputeStatementKind,
    // An invalid statement, of the given kind.
    Invalid: exports.$InvalidDisputeStatementKind,
});
/**
 * A set of statements about a specific candidate.
 */
exports.$DisputeStatementSet = $.Struct({
    // The candidate referenced by this set.
    candidateHash: exports.$CandidateHash,
    // The session index of the candidate.
    session: exports.$SessionIndex,
    // Statements about the candidate.
    statements: $.Vec($.Tuple(exports.$DisputeStatement, exports.$ParaValidatorIndex, exports.$ValidatorSignature)),
});
/**
 * A set of dispute statements.
 */
exports.$MultiDisputeStatementSet = $.Vec(exports.$DisputeStatementSet);
exports.$ScrapedOnChainVotes = $.Struct({
    // The session in which the block was included.
    session: exports.$SessionIndex,
    // Set of backing validators for each candidate, represented by its candidate
    // receipt.
    backingValidatorsPerCandidate: $.Vec($.Tuple(exports.$CandidateReceipt, $.Vec($.Tuple(exports.$ParaValidatorIndex, exports.$ValidityAttestation)))),
    // On-chain-recorded set of disputes.
    // Note that the above `backing_validators` are
    // unrelated to the backers of the disputes candidates.
    disputes: exports.$MultiDisputeStatementSet,
});
/**
 * Information about validator sets of a session.
 *
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/0ff3f4d3af0036bbae624011b720bfd5e93ce91b/polkadot/primitives/src/v6/mod.rs#L1714-L1774
 */
exports.$SessionInfo = $.Struct({
    // All the validators actively participating in parachain consensus.
    // Indices are into the broader validator set.
    activeValidatorIndices: $.Vec(exports.$ParaValidatorIndex),
    // A secure random seed for the session, gathered from BABE.
    randomSeed: $.FixedHex(32),
    // The amount of sessions to keep for disputes.
    disputePeriod: exports.$SessionIndex,
    // Validators in canonical ordering.
    validators: $.Vec(exports.$ValidatorId),
    // Validators' authority discovery keys for the session in canonical ordering.
    discoveryKeys: $.Vec(index_js_1.$AccountId32),
    // The assignment keys for validators.
    assignmentKeys: $.Vec(index_js_1.$AccountId32),
    // Validators in shuffled ordering - these are the validator groups as produced
    // by the `Scheduler` module for the session and are typically referred to by
    // `GroupIndex`.
    validatorGroups: $.Vec($.Vec(exports.$ParaValidatorIndex)),
    // The number of availability cores used by the protocol during this session.
    nCores: $.u32,
    // The zeroth delay tranche width.
    zerothDelayTrancheWidth: $.u32,
    // The number of samples we do of `relay_vrf_modulo`.
    relayVrfModuloSamples: $.u32,
    // The number of delay tranches in total.
    nDelayTranches: $.u32,
    // How many slots (BABE / SASSAFRAS) must pass before an assignment is considered a
    // no-show.
    noShowSlots: $.u32,
    // The number of validators needed to approve a block.
    neededApprovals: $.u32,
});
/**
 * A statement from the specified validator whether the given validation code passes PVF
 * pre-checking or not anchored to the given session index.
 */
exports.$PvfCheckStatement = $.Struct({
    // `true` if the subject passed pre-checking and `false` otherwise.
    accept: $.bool,
    // The validation code hash that was checked.
    subject: exports.$ValidationCodeHash,
    // The index of a session during which this statement is considered valid.
    sessionIndex: exports.$SessionIndex,
    // The index of the validator from which this statement originates.
    validatorIndex: exports.$ParaValidatorIndex,
});
/**
 * The entire state of a dispute.
 */
exports.$DisputeState = $.Struct({
    // A bitfield indicating all validators for the candidate.
    validatorsFor: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>, // one bit per validator.
    // A bitfield indicating all validators against the candidate.
    validatorsAgainst: $.bitSequence, //BitVec<u8, bitvec::order::Lsb0>, // one bit per validator.
    // The block number at which the dispute started on-chain.
    start: index_js_1.$BlockNumber,
    // The block number at which the dispute concluded on-chain.
    concludedAt: $.Option(index_js_1.$BlockNumber),
});
/**
 * Type discriminator for PVF preparation
 */
exports.$PvfPrepKind = $.FlatEnum([
    // For prechecking requests.
    'Precheck',
    // For execution and heads-up requests.
    'Prepare',
]);
/**
 * Type discriminator for PVF execution.
 */
exports.$PvfExecKind = $.FlatEnum([
    // For backing requests.
    'Backing',
    // For approval and dispute request.
    'Approval',
]);
/**
 * The different executor parameters for changing the execution environment semantics.
 */
exports.$ExecutorParam = $.Enum({
    // Maximum number of memory pages (64KiB bytes per page) the executor can allocate.
    // A valid value lies within (0, 65536].
    MaxMemoryPages: { index: 1, value: $.u32 },
    // Wasm logical stack size limit (max. number of Wasm values on stack).
    // A valid value lies within [[`LOGICAL_MAX_LO`], [`LOGICAL_MAX_HI`]].
    //
    // For WebAssembly, the stack limit is subject to implementations, meaning that it may vary on
    // different platforms. However, we want execution to be deterministic across machines of
    // different architectures, including failures like stack overflow. For deterministic
    // overflow, we rely on a **logical** limit, the maximum number of values allowed to be pushed
    // on the stack.
    StackLogicalMax: { index: 2, value: $.u32 },
    // Executor machine stack size limit, in bytes.
    // If `StackLogicalMax` is also present, a valid value should not fall below
    // 128 * `StackLogicalMax`.
    //
    // For deterministic overflow, `StackLogicalMax` should be reached before the native stack is
    // exhausted.
    StackNativeMax: { index: 3, value: $.u32 },
    // Max. amount of memory the preparation worker is allowed to use during
    // pre-checking, in bytes.
    // Valid max. memory ranges from [`PRECHECK_MEM_MAX_LO`] to [`PRECHECK_MEM_MAX_HI`].
    PrecheckingMaxMemory: { index: 4, value: $.u64 },
    // PVF preparation timeouts, in millisecond.
    // Always ensure that `precheck_timeout` < `lenient_timeout`.
    // When absent, the default values will be used.
    PvfPrepTimeout: { index: 5, value: $.Tuple(exports.$PvfPrepKind, $.u64) },
    // PVF execution timeouts, in millisecond.
    // Always ensure that `backing_timeout` < `approval_timeout`.
    // When absent, the default values will be used.
    PvfExecTimeout: { index: 6, value: $.Tuple(exports.$PvfExecKind, $.u64) },
    // Enables WASM bulk memory proposal
    WasmExtBulkMemory: null,
});
/**
 * # Deterministically serialized execution environment semantics
 * Represents an arbitrary semantics of an arbitrary execution environment, so should be kept as
 * abstract as possible.
 */
exports.$ExecutorParams = $.Vec(exports.$ExecutorParam);
/**
 * The kind of the dispute offence.
 */
exports.$SlashingOffenceKind = $.FlatEnum([
    // A severe offence when a validator backed an invalid block.
    'ForInvalid',
    // A minor offence when a validator disputed a valid block.
    'AgainstValid',
]);
/**
 * Slashes that are waiting to be applied once we have validator key
 * identification.
 */
exports.$PendingSlashes = $.Struct({
    // Indices and keys of the validators who lost a dispute and are pending
    // slashes.
    keys: $.map(exports.$ParaValidatorIndex, exports.$ValidatorId),
    // The dispute outcome.
    kind: exports.$SlashingOffenceKind,
});
/**
 * Timeslots should uniquely identify offences and are used for the offence
 * deduplication.
 */
exports.$DisputesTimeSlot = $.Struct({
    // The order of the fields matters for `derive(Ord)`.
    // Session index when the candidate was backed/included.
    sessionIndex: exports.$SessionIndex,
    // Candidate hash of the disputed candidate.
    candidateHash: exports.$CandidateHash,
});
/**
 * We store most of the information about a lost dispute on chain. This struct
 * is required to identify and verify it.
 */
exports.$DisputeProof = $.Struct({
    // Time slot when the dispute occured.
    timeSlot: exports.$DisputesTimeSlot,
    // The dispute outcome.
    kind: exports.$SlashingOffenceKind,
    // The index of the validator who lost a dispute.
    validatorIndex: exports.$ParaValidatorIndex,
    // The parachain session key of the validator.
    validatorId: exports.$ValidatorId,
});
/**
 * Constraints on inbound HRMP channels.
 */
exports.$InboundHrmpLimitations = $.Struct({
    // An exhaustive set of all valid watermarks, sorted ascending.
    //
    // It's only expected to contain block numbers at which messages were
    // previously sent to a para, excluding most recent head.
    valid_watermarks: $.Vec(index_js_1.$BlockNumber),
});
/**
 * Constraints on outbound HRMP channels.
 */
exports.$OutboundHrmpChannelLimitations = $.Struct({
    // The maximum bytes that can be written to the channel.
    bytesRemaining: $.u32,
    // The maximum messages that can be written to the channel.
    messagesRemaining: $.u32,
});
/**
 * A possible upgrade restriction that prevents a parachain from performing an upgrade.
 */
exports.$UpgradeRestriction = $.Enum({
    // There is an upgrade restriction and there are no details about its specifics nor how long
    // it could last.
    Present: null,
});
/**
 * Constraints on the actions that can be taken by a new parachain
 * block. These limitations are implicitly associated with some particular
 * parachain, which should be apparent from usage.
 */
exports.$Constraints = $.Struct({
    // The minimum relay-parent number accepted under these constraints.
    minRelayParentNumber: index_js_1.$BlockNumber,
    // The maximum Proof-of-Validity size allowed, in bytes.
    maxPovSize: $.u32,
    // The maximum new validation code size allowed, in bytes.
    maxCodeSize: $.u32,
    // The amount of UMP messages remaining.
    umpRemaining: $.u32,
    // The amount of UMP bytes remaining.
    umpRemainingBytes: $.u32,
    // The maximum number of UMP messages allowed per candidate.
    maxUmpNumPerCandidate: $.u32,
    // Remaining DMP queue. Only includes sent-at block numbers.
    dmpRemainingMessages: $.Vec(index_js_1.$BlockNumber),
    // The limitations of all registered inbound HRMP channels.
    hrmpInbound: exports.$InboundHrmpLimitations,
    // The limitations of all registered outbound HRMP channels.
    hrmpChannelsOut: $.Vec($.Tuple(exports.$ParaId, exports.$OutboundHrmpChannelLimitations)),
    // The maximum number of HRMP messages allowed per candidate.
    maxHrmpNumPerCandidate: $.u32,
    // The required parent head-data of the parachain.
    requiredParent: exports.$HeadData,
    // The expected validation-code-hash of this parachain.
    validationCodeHash: exports.$ValidationCodeHash,
    // The code upgrade restriction signal as-of this parachain.
    upgradeRestriction: $.Option(exports.$UpgradeRestriction),
    // The future validation code hash, if any, and at what relay-parent
    // number the upgrade would be minimally applied.
    futureValidationCode: $.Option($.Tuple(index_js_1.$BlockNumber, exports.$ValidationCodeHash)),
});
/**
 * A candidate pending availability.
 */
exports.$CandidatePendingAvailability = $.Struct({
    // The hash of the candidate.
    candidateHash: exports.$CandidateHash,
    // The candidate's descriptor.
    descriptor: exports.$CandidateDescriptor,
    // The commitments of the candidate.
    commitments: exports.$CandidateCommitments,
    // The candidate's relay parent's number.
    relayParentNumber: index_js_1.$BlockNumber,
    // The maximum Proof-of-Validity size allowed, in bytes.
    maxPovSize: $.u32,
});
exports.$BackingState = $.Struct({
    // The state-machine constraints of the parachain.
    constraints: exports.$Constraints,
    // The candidates pending availability. These should be ordered, i.e. they should form
    // a sub-chain, where the first candidate builds on top of the required parent of the
    // constraints and each subsequent builds on top of the previous head-data.
    pendingAvailability: $.Vec(exports.$CandidatePendingAvailability),
});
/**
 * Candidate's acceptance limitations for asynchronous backing per relay parent.
 */
exports.$AsyncBackingParams = $.Struct({
    // The maximum number of para blocks between the para head in a relay parent
    // and a new candidate. Restricts nodes from building arbitrary long chains
    // and spamming other validators.
    //
    // When async backing is disabled, the only valid value is 0.
    maxCandidateDepth: $.u32,
    // How many ancestors of a relay parent are allowed to build candidates on top
    // of.
    //
    // When async backing is disabled, the only valid value is 0.
    allowedAncestryLen: $.u32,
});
/**
 * Bit indices in the `HostConfiguration.node_features` that correspond to different node features.
 */
exports.$NodeFeatures = $.bitSequence;
