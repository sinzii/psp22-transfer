"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$Header = exports.$Digest = exports.$DigestItem = exports.$ConsensusEngineId = exports.ConsensusEngineId = exports.$HeaderBlockNumber = exports.$BlockNumber = void 0;
const $ = __importStar(require("@dedot/shape"));
const utils_1 = require("@dedot/utils");
const Hash_js_1 = require("./Hash.js");
exports.$BlockNumber = $.withMetadata($.metadata('$BlockNumber'), $.u32);
exports.$HeaderBlockNumber = $.withMetadata($.metadata('$HeaderBlockNumber'), $.compactU32);
exports.$HeaderBlockNumber.registerDecoder(utils_1.isHex, 
// TODO make this more clear?
// BlockNumber in $Header codec is a hex in BE format
// So Le=false here is to support decode block number in $Header
(_, input) => parseInt(input, 16));
class ConsensusEngineId {
    id;
    constructor(id) {
        this.id = id;
    }
    get name() {
        return (0, utils_1.hexToString)(this.id);
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.name;
    }
}
exports.ConsensusEngineId = ConsensusEngineId;
exports.$ConsensusEngineId = $.instance(ConsensusEngineId, $.Tuple($.FixedHex(4)), (value) => {
    if (value instanceof ConsensusEngineId) {
        return [value.id];
    }
    else {
        return [value];
    }
});
/**
 * Digest item that is able to encode/decode 'system' digest items and
 * provide opaque access to other items.
 *
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/0e49ed72aa365475e30069a5c30e251a009fdacf/substrate/primitives/runtime/src/generic/digest.rs#L72-L109
 */
exports.$DigestItem = $.Enum({
    Other: { index: 0, value: $.PrefixedHex },
    Consensus: { index: 4, value: $.Tuple(exports.$ConsensusEngineId, $.PrefixedHex) },
    Seal: { index: 5, value: $.Tuple(exports.$ConsensusEngineId, $.PrefixedHex) },
    PreRuntime: { index: 6, value: $.Tuple(exports.$ConsensusEngineId, $.PrefixedHex) },
    RuntimeEnvironmentUpdated: { index: 8 },
});
exports.$Digest = $.Struct({
    logs: $.Vec(exports.$DigestItem),
});
exports.$Header = $.Struct({
    parentHash: Hash_js_1.$Hash,
    number: exports.$HeaderBlockNumber,
    stateRoot: Hash_js_1.$Hash,
    extrinsicsRoot: Hash_js_1.$Hash,
    digest: exports.$Digest,
});
