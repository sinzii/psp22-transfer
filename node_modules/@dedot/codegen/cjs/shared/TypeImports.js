"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeImports = void 0;
class TypeImports {
    // Portable types from chain/metadata
    portableTypes;
    // Known types that has a corresponding codec defined in @dedot/codecs
    codecTypes;
    // Known types that're not codecs or chain/portable types defined in @dedot/types
    knownTypes;
    knownJsonRpcTypes;
    // External types to define explicitly
    outTypes;
    // Know types defined in @dedot/contracts
    contractTypes;
    // Know types defined in @dedot/api/chaintypes or dedot/chaintypes
    chainTypes;
    constructor() {
        this.portableTypes = new Set();
        this.codecTypes = new Set();
        this.knownTypes = new Set();
        this.knownJsonRpcTypes = new Set();
        this.outTypes = new Set();
        this.contractTypes = new Set();
        this.chainTypes = new Set();
    }
    clear() {
        this.portableTypes.clear();
        this.codecTypes.clear();
        this.knownTypes.clear();
        this.knownJsonRpcTypes.clear();
        this.outTypes.clear();
        this.contractTypes.clear();
        this.chainTypes.clear();
    }
    toImports(config) {
        const { excludeModules = [], useSubPaths = false } = config || {};
        // TODO generate outTypes!
        const prefix = useSubPaths ? '' : '@';
        const toImports = [
            [this.knownTypes, `${prefix}dedot/types`],
            [this.knownJsonRpcTypes, `${prefix}dedot/types/json-rpc`],
            [this.codecTypes, `${prefix}dedot/codecs`],
            [this.contractTypes, `${prefix}dedot/contracts`],
            [this.chainTypes, prefix ? '@dedot/api/chaintypes' : 'dedot/chaintypes'],
            [this.portableTypes, './types'],
        ];
        return toImports
            .filter(([_, module]) => !excludeModules.includes(module))
            .map(([types, module]) => this.#toImportLine(types, module))
            .filter((line) => line.length > 0)
            .join('\n');
    }
    #toImportLine(types, module) {
        const typesToImports = [...types];
        if (typesToImports.length === 0)
            return '';
        return `import type {${typesToImports.join(', ')}} from "${module}"`;
    }
    addPortableType(...types) {
        types.forEach((one) => this.portableTypes.add(one));
    }
    addCodecType(...types) {
        types.forEach((one) => this.codecTypes.add(one));
    }
    addKnownType(...types) {
        types.forEach((one) => this.knownTypes.add(one));
    }
    addKnownJsonRpcType(...types) {
        types.forEach((one) => this.knownJsonRpcTypes.add(one));
    }
    addOutType(...types) {
        types.forEach((one) => this.outTypes.add(one));
    }
    addContractType(...types) {
        types.forEach((one) => this.contractTypes.add(one));
    }
    addChainType(...types) {
        types.forEach((one) => this.chainTypes.add(one));
    }
}
exports.TypeImports = TypeImports;
