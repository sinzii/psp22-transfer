"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeApisGen = void 0;
const runtime_specs_1 = require("@dedot/runtime-specs");
const utils_1 = require("@dedot/utils");
const index_js_1 = require("../../shared/index.js");
const utils_js_1 = require("../../utils.js");
const ApiGen_js_1 = require("./ApiGen.js");
class RuntimeApisGen extends ApiGen_js_1.ApiGen {
    typesGen;
    runtimeApis;
    constructor(typesGen, runtimeApis) {
        super(typesGen);
        this.typesGen = typesGen;
        this.runtimeApis = runtimeApis;
    }
    generate(useSubPaths = false) {
        this.typesGen.clearCache();
        this.typesGen.typeImports.addKnownType('GenericRuntimeApis', 'GenericRuntimeApiMethod', 'RpcVersion');
        let runtimeCallsOut = '';
        if (this.metadata.apis.length > 0) {
            this.metadata.apis.forEach((runtimeApi) => {
                const { name: runtimeApiName, methods } = runtimeApi;
                runtimeCallsOut += (0, utils_js_1.commentBlock)(`@runtimeapi: ${runtimeApiName} - ${(0, utils_1.calcRuntimeApiHash)(runtimeApiName)}`);
                runtimeCallsOut += `${(0, utils_1.stringCamelCase)(runtimeApiName)}: {
            ${methods.map((method) => this.#generateMethodDef(runtimeApiName, method)).join('\n')} 
              
            ${(0, utils_js_1.commentBlock)('Generic runtime api call')}[method: string]: GenericRuntimeApiMethod<Rv>
        }`;
            });
        }
        else {
            const specs = this.#targetRuntimeApiSpecs();
            specs.forEach(({ methods, runtimeApiName, runtimeApiHash, version }) => {
                runtimeCallsOut += (0, utils_js_1.commentBlock)(`@runtimeapi: ${runtimeApiName} - ${runtimeApiHash}`, `@version: ${version}`);
                runtimeCallsOut += `${(0, utils_1.stringCamelCase)(runtimeApiName)}: {
            ${Object.keys(methods)
                    .map((methodName) => this.#generateMethodDefFromSpec({
                    ...methods[methodName],
                    runtimeApiName,
                    methodName,
                }))
                    .join('\n')} 
              
            ${(0, utils_js_1.commentBlock)('Generic runtime api call')}[method: string]: GenericRuntimeApiMethod<Rv>
          }`;
            });
        }
        const importTypes = this.typesGen.typeImports.toImports({ useSubPaths });
        const template = (0, utils_js_1.compileTemplate)('chaintypes/templates/runtime.hbs');
        return (0, utils_js_1.beautifySourceCode)(template({ importTypes, runtimeCallsOut }));
    }
    #isOptionalType(type) {
        return type.startsWith('Option<') || type.endsWith('| undefined');
    }
    #isOptionalParam(params, type, idx) {
        return this.#isOptionalType(type) && params.slice(idx + 1).every(({ type }) => this.#isOptionalType(type));
    }
    #generateMethodDefFromSpec(spec) {
        const { docs = [], params, type, runtimeApiName, methodName } = spec;
        const callName = `${runtimeApiName}_${(0, utils_1.stringSnakeCase)(methodName)}`;
        const defaultDocs = [`@callname: ${callName}`];
        this.#addTypeImport(type, false);
        params.forEach(({ type }) => this.#addTypeImport(type));
        const typedParams = params.map((param, idx) => ({
            ...param,
            isOptional: this.#isOptionalParam(params, param.type, idx),
            plainType: this.#getGeneratedTypeName(param.type),
        }));
        const paramsOut = typedParams
            .map(({ name, isOptional, plainType }) => `${(0, utils_1.stringCamelCase)(name)}${isOptional ? '?' : ''}: ${plainType}`)
            .join(', ');
        const typeOut = this.#getGeneratedTypeName(type, false);
        return `${(0, utils_js_1.commentBlock)(docs, '\n', defaultDocs, typedParams.map(({ plainType, name }) => `@param {${plainType}} ${name}`))}${methodName}: GenericRuntimeApiMethod<Rv, (${paramsOut}) => Promise<${typeOut}>>`;
    }
    #generateMethodDef(runtimeApiName, methodDef) {
        const { name: methodName, inputs, output, docs } = methodDef;
        const callName = `${runtimeApiName}_${(0, utils_1.stringSnakeCase)(methodName)}`;
        const defaultDocs = [`@callname: ${callName}`];
        const typeOut = this.typesGen.generateType(output, 1, true);
        this.#addTypeImport(typeOut, false);
        const typedInputs = inputs
            .map((input, idx) => ({
            ...input,
            type: this.typesGen.generateType(input.typeId, 1),
        }))
            .map((input, idx, inputs) => ({
            ...input,
            isOptional: this.#isOptionalParam(inputs, input.type, idx),
        }));
        this.#addTypeImport(typedInputs.map((t) => t.type));
        const paramsOut = typedInputs
            .map(({ name, type, isOptional }) => `${(0, utils_1.stringCamelCase)(name)}${isOptional ? '?' : ''}: ${type}`)
            .join(', ');
        return `${(0, utils_js_1.commentBlock)(docs, '\n', defaultDocs, typedInputs.map(({ type, name }) => `@param {${type}} ${name}`))}${(0, utils_1.stringCamelCase)(methodName)}: GenericRuntimeApiMethod<Rv, (${paramsOut}) => Promise<${typeOut}>>`;
    }
    #targetRuntimeApiSpecs() {
        const specs = Object.entries(this.runtimeApis).map(([runtimeApiHash, version]) => {
            const runtimeApiSpec = this.#findRuntimeApiSpec(runtimeApiHash, version);
            if (!runtimeApiSpec)
                return;
            return {
                ...runtimeApiSpec,
                runtimeApiHash,
            };
        });
        return specs.reduce((o, spec) => {
            if (!spec) {
                return o;
            }
            return [...o, spec];
        }, []);
    }
    #findRuntimeApiSpec = (runtimeApiHash, version) => {
        const runtimeApiName = (0, runtime_specs_1.getRuntimeApiNames)().find((one) => (0, utils_1.calcRuntimeApiHash)(one) === runtimeApiHash);
        return (0, runtime_specs_1.getRuntimeApiSpecs)().find((one) => one.runtimeApiName === runtimeApiName && one.version === version);
    };
    // TODO check typeIn, typeOut if param type, or rpc type isScale
    #addTypeImport(type, toTypeIn = true) {
        if (Array.isArray(type)) {
            type.forEach((one) => this.#addTypeImport(one, toTypeIn));
            return;
        }
        type = type.trim();
        if ((0, utils_js_1.isNativeType)(type)) {
            return;
        }
        // Handle generic wrapper types
        const matchArray = type.match(utils_js_1.WRAPPER_TYPE_REGEX);
        if (matchArray) {
            const [_, $1, $2] = matchArray;
            this.#addTypeImport($1, toTypeIn);
            if ($2.match(utils_js_1.WRAPPER_TYPE_REGEX) || $2.match(utils_js_1.TUPLE_TYPE_REGEX)) {
                this.#addTypeImport($2, toTypeIn);
            }
            else {
                this.#addTypeImport($2.split(','), toTypeIn);
            }
            return;
        }
        // Check tuple type
        if (type.match(utils_js_1.TUPLE_TYPE_REGEX)) {
            this.#addTypeImport(type.slice(1, -1).split(','), toTypeIn);
            return;
        }
        if (type.includes(' | ')) {
            this.#addTypeImport(type.split(' | ').map((one) => one.trim()), toTypeIn);
            return;
        }
        try {
            const codecType = this.#getCodecType(type, toTypeIn);
            if ((0, utils_js_1.isNativeType)(codecType))
                return;
            this.typesGen.typeImports.addCodecType(codecType);
            return;
        }
        catch (e) { }
        this.typesGen.addTypeImport(type);
    }
    #getGeneratedTypeName(type, toTypeIn = true) {
        try {
            const matchArray = type.match(utils_js_1.WRAPPER_TYPE_REGEX);
            if (matchArray) {
                const [_, $1, $2] = matchArray;
                const wrapperTypeName = this.#getCodecType($1, toTypeIn);
                if ($2.match(utils_js_1.WRAPPER_TYPE_REGEX) || $2.match(utils_js_1.TUPLE_TYPE_REGEX)) {
                    return `${wrapperTypeName}<${this.#getGeneratedTypeName($2, toTypeIn)}>`;
                }
                const innerTypeNames = $2
                    .split(',')
                    .map((one) => this.#getGeneratedTypeName(one.trim(), toTypeIn))
                    .join(', ');
                return `${wrapperTypeName}<${innerTypeNames}>`;
            }
            else if (type.match(utils_js_1.TUPLE_TYPE_REGEX)) {
                const innerTypeNames = type
                    .slice(1, -1)
                    .split(',')
                    .map((one) => this.#getGeneratedTypeName(one.trim(), toTypeIn))
                    .join(', ');
                return `[${innerTypeNames}]`;
            }
            return this.#getCodecType(type, toTypeIn);
        }
        catch (e) { }
        return type;
    }
    #getCodecType(type, toTypeIn = true) {
        const { typeIn, typeOut } = (0, index_js_1.findKnownCodecType)(type);
        return toTypeIn ? typeIn : typeOut;
    }
}
exports.RuntimeApisGen = RuntimeApisGen;
