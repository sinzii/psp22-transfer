"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypes = exports.generateTypesFromEndpoint = void 0;
const api_1 = require("@dedot/api");
const providers_1 = require("@dedot/providers");
const utils_1 = require("@dedot/utils");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const index_js_1 = require("./generator/index.js");
async function generateTypesFromEndpoint(chain, endpoint, outDir, extension = 'd.ts', useSubPaths = false) {
    // Immediately throw error if cannot connect to provider for the first time.
    const client = await api_1.LegacyClient.new(new providers_1.WsProvider({ endpoint, retryDelayMs: 0, timeout: 0 }));
    const { methods } = await client.rpc.rpc_methods();
    chain = chain || client.runtimeVersion.specName || 'local';
    const result = await generateTypes(chain, client.metadata.latest, methods, client.runtimeVersion, outDir, extension, useSubPaths);
    await client.disconnect();
    return result;
}
exports.generateTypesFromEndpoint = generateTypesFromEndpoint;
async function generateTypes(chain, metadata, rpcMethods, runtimeVersion, outDir = '.', extension = 'd.ts', useSubPaths = false) {
    const dirPath = path.resolve(outDir, (0, utils_1.stringDashCase)(chain));
    const defTypesFileName = path.join(dirPath, `types.${extension}`);
    const constsTypesFileName = path.join(dirPath, `consts.${extension}`);
    const queryTypesFileName = path.join(dirPath, `query.${extension}`);
    const jsonRpcFileName = path.join(dirPath, `json-rpc.${extension}`);
    const indexFileName = path.join(dirPath, `index.${extension}`);
    const errorsFileName = path.join(dirPath, `errors.${extension}`);
    const eventsFileName = path.join(dirPath, `events.${extension}`);
    const runtimeApisFileName = path.join(dirPath, `runtime.${extension}`);
    const txFileName = path.join(dirPath, `tx.${extension}`);
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
    }
    const interfaceName = `${(0, utils_1.stringPascalCase)(chain)}Api`;
    const typesGen = new index_js_1.TypesGen(metadata);
    const constsGen = new index_js_1.ConstsGen(typesGen);
    const queryGen = new index_js_1.QueryGen(typesGen);
    const jsonRpcGen = new index_js_1.JsonRpcGen(typesGen, rpcMethods);
    const indexGen = new index_js_1.IndexGen(interfaceName, runtimeVersion);
    const errorsGen = new index_js_1.ErrorsGen(typesGen);
    const eventsGen = new index_js_1.EventsGen(typesGen);
    const runtimeApisGen = new index_js_1.RuntimeApisGen(typesGen, runtimeVersion.apis);
    const txGen = new index_js_1.TxGen(typesGen);
    fs.writeFileSync(defTypesFileName, await typesGen.generate(useSubPaths));
    fs.writeFileSync(errorsFileName, await errorsGen.generate(useSubPaths));
    fs.writeFileSync(eventsFileName, await eventsGen.generate(useSubPaths));
    fs.writeFileSync(jsonRpcFileName, await jsonRpcGen.generate(useSubPaths));
    fs.writeFileSync(queryTypesFileName, await queryGen.generate(useSubPaths));
    fs.writeFileSync(constsTypesFileName, await constsGen.generate(useSubPaths));
    fs.writeFileSync(txFileName, await txGen.generate(useSubPaths));
    fs.writeFileSync(indexFileName, await indexGen.generate(useSubPaths));
    fs.writeFileSync(runtimeApisFileName, await runtimeApisGen.generate(useSubPaths));
    return { interfaceName, outputFolder: dirPath };
}
exports.generateTypes = generateTypes;
