"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryGen = void 0;
const contracts_1 = require("@dedot/contracts");
const utils_1 = require("@dedot/utils");
const utils_js_1 = require("../../utils.js");
class QueryGen {
    contractMetadata;
    typesGen;
    constructor(contractMetadata, typeGen) {
        this.contractMetadata = contractMetadata;
        this.typesGen = typeGen;
    }
    generate(useSubPaths = false) {
        this.typesGen.clearCache();
        this.typesGen.typeImports.addKnownType('GenericSubstrateApi');
        this.typesGen.typeImports.addContractType('GenericContractQuery', 'GenericContractQueryCall', 'ContractCallOptions', 'GenericContractCallResult', 'ContractCallResult');
        const { messages } = this.contractMetadata.spec;
        const queryCallsOut = this.doGenerate(messages, 'ContractCallOptions');
        const importTypes = this.typesGen.typeImports.toImports({ useSubPaths });
        const template = (0, utils_js_1.compileTemplate)('typink/templates/query.hbs');
        return (0, utils_js_1.beautifySourceCode)(template({ importTypes, queryCallsOut }));
    }
    doGenerate(messages, optionsTypeName) {
        let callsOut = '';
        messages.forEach((messageDef) => {
            const { label, docs, selector, args } = messageDef;
            // In case there is an arg has label `options`,
            // we use the name `_options` for the last options param
            // This is just and edge case, so this approach works for now
            const optionsParamName = args.some(({ label }) => label === 'options') ? '_options' : 'options';
            callsOut += `${(0, utils_js_1.commentBlock)(docs, '\n', args.map((arg) => `@param {${this.typesGen.generateType(arg.type.type, 1)}} ${(0, utils_1.stringCamelCase)(arg.label)}`), optionsTypeName ? `@param {${optionsTypeName}} ${optionsParamName}` : '', '\n', `@selector ${selector}`)}`;
            callsOut += `${(0, contracts_1.normalizeLabel)(label)}: ${this.generateMethodDef(messageDef, optionsParamName)};\n\n`;
        });
        return callsOut;
    }
    generateMethodDef(def, optionsParamName = 'options') {
        const { args, returnType } = def;
        const paramsOut = this.generateParamsOut(args);
        const typeOutRaw = this.typesGen.generateType(returnType.type, 0, true);
        // Unwrap langError result
        const typeOut = typeOutRaw.match(/^(\w+)<(.*), (.*)>$/).at(2);
        return `GenericContractQueryCall<ChainApi, (${paramsOut && `${paramsOut},`} ${optionsParamName}?: ContractCallOptions) => Promise<GenericContractCallResult<${typeOut}, ContractCallResult<ChainApi>>>>`;
    }
    generateParamsOut(args) {
        return args
            .map(({ type: { type }, label }) => `${(0, utils_1.stringCamelCase)(label)}: ${this.typesGen.generateType(type, 1)}`)
            .join(', ');
    }
}
exports.QueryGen = QueryGen;
