"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorQueryGen = void 0;
const utils_js_1 = require("../../utils.js");
const QueryGen_js_1 = require("./QueryGen.js");
class ConstructorQueryGen extends QueryGen_js_1.QueryGen {
    generate(useSubPaths = false) {
        this.typesGen.clearCache();
        this.typesGen.typeImports.addKnownType('GenericSubstrateApi');
        this.typesGen.typeImports.addContractType('GenericConstructorQuery', 'GenericConstructorQueryCall', 'GenericConstructorCallResult', 'ConstructorCallOptions', 'ContractInstantiateResult');
        const { constructors } = this.contractMetadata.spec;
        const constructorsOut = this.doGenerate(constructors, 'ConstructorCallOptions');
        const importTypes = this.typesGen.typeImports.toImports({ useSubPaths });
        const template = (0, utils_js_1.compileTemplate)('typink/templates/constructor-query.hbs');
        return (0, utils_js_1.beautifySourceCode)(template({ importTypes, constructorsOut }));
    }
    generateMethodDef(def, optionsParamName = 'options') {
        const { args, returnType } = def;
        const paramsOut = this.generateParamsOut(args);
        const typeOutRaw = this.typesGen.generateType(returnType.type, 0, true);
        // Unwrap langError result
        const typeOut = typeOutRaw.match(/^(\w+)<(.*), (.*)>$/).at(2);
        return `GenericConstructorQueryCall<ChainApi, (${paramsOut && `${paramsOut},`} ${optionsParamName}?: ConstructorCallOptions) => Promise<GenericConstructorCallResult<${typeOut}, ContractInstantiateResult<ChainApi>>>>`;
    }
}
exports.ConstructorQueryGen = ConstructorQueryGen;
