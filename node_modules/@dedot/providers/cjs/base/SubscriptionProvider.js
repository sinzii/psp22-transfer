"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionProvider = void 0;
const utils_1 = require("@dedot/utils");
const error_js_1 = require("../error.js");
/**
 * @name SubscriptionProvider
 * @description
 * A base class for providers that support subscriptions (e.g: Websocket, Smoldot)
 */
class SubscriptionProvider extends utils_1.EventEmitter {
    _status;
    _handlers;
    _subscriptions;
    _pendingNotifications;
    constructor() {
        super();
        this._status = 'disconnected';
        this._handlers = {};
        this._subscriptions = {};
        this._pendingNotifications = {};
    }
    connect() {
        throw new Error('Unimplemented!');
    }
    disconnect() {
        throw new Error('Unimplemented!');
    }
    async doSend(request) {
        throw new Error('Unimplemented!');
    }
    _setStatus(status) {
        if (this._status === status)
            return;
        this._status = status;
        this.emit(status);
    }
    _cleanUp() {
        this._handlers = {};
        this._subscriptions = {};
        this._pendingNotifications = {};
        this.clearEvents();
    }
    get status() {
        return this._status;
    }
    _onReceiveResponse = (response) => {
        const data = JSON.parse(response);
        const isNotification = !data.id && data.method;
        if (isNotification) {
            this._handleNotification(data);
        }
        else {
            this._handleResponse(data);
        }
    };
    _handleResponse(response) {
        const { id, error, result } = response;
        const handler = this._handlers[id];
        if (!handler) {
            console.error(`Received response with unknown id: ${id}`);
            return;
        }
        const { defer } = handler;
        if (error) {
            defer.reject(new error_js_1.JsonRpcError(error));
        }
        else {
            defer.resolve(result);
        }
        delete this._handlers[id];
    }
    _handleNotification(response) {
        const { method: subname, params } = response;
        const { subscription: subscriptionId, result, error } = params;
        const subkey = `${subname}::${subscriptionId}`;
        const substate = this._subscriptions[subkey];
        // TODO check if there is an handler exists for the subscription
        // TODO track if the subkey was existed before and has already been canceled
        //      we'll ignore those pending notifications
        if (!substate) {
            if (!this._pendingNotifications[subkey]) {
                this._pendingNotifications[subkey] = [];
            }
            this._pendingNotifications[subkey].push(response);
            return;
        }
        const { callback } = substate;
        if (error) {
            callback(new error_js_1.JsonRpcError(error), null, substate.subscription);
        }
        else {
            callback(null, result, substate.subscription);
        }
    }
    async send(method, params) {
        const defer = (0, utils_1.deferred)();
        try {
            const request = this.#prepareRequest(method, params);
            this._handlers[request.id] = {
                defer,
                request,
                from: Date.now(),
            };
            await this.doSend(request);
        }
        catch (e) {
            defer.reject(e);
        }
        return defer.promise;
    }
    async subscribe(input, callback) {
        const { subname, subscribe, params, unsubscribe } = input;
        const subscriptionId = await this.send(subscribe, params);
        const subkey = `${subname}::${subscriptionId}`;
        const subscription = {
            unsubscribe: async () => {
                delete this._subscriptions[subkey];
                await this.send(unsubscribe, [subscriptionId]);
            },
            subscriptionId,
        };
        this._subscriptions[subkey] = {
            input,
            callback,
            subscription,
        };
        // Handle pending notifications
        if (this._pendingNotifications[subkey]) {
            this._pendingNotifications[subkey].forEach((notification) => {
                this._handleNotification(notification);
            });
            delete this._pendingNotifications[subkey];
        }
        return subscription;
    }
    #id = 0;
    #prepareRequest(method, params) {
        const id = ++this.#id;
        return {
            id,
            jsonrpc: '2.0',
            method,
            params,
        };
    }
}
exports.SubscriptionProvider = SubscriptionProvider;
