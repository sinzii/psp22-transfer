"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckMortality = exports.MORTAL_PERIOD = exports.FALLBACK_PERIOD = exports.FALLBACK_MAX_HASH_COUNT = exports.MAX_FINALITY_LAG = void 0;
const utils_1 = require("@dedot/utils");
const SignedExtension_js_1 = require("../SignedExtension.js");
exports.MAX_FINALITY_LAG = 5;
exports.FALLBACK_MAX_HASH_COUNT = 250;
exports.FALLBACK_PERIOD = 6 * 1000;
exports.MORTAL_PERIOD = 5 * 60 * 1000;
/**
 * @description Check for transaction mortality.
 */
class CheckMortality extends SignedExtension_js_1.SignedExtension {
    #signingHeader;
    async init() {
        this.#signingHeader = await this.#getSigningHeader();
        this.data = { period: this.#calculateMortalLength(), current: BigInt(this.#signingHeader.number) };
        this.additionalSigned = this.#signingHeader.hash;
    }
    async #getSigningHeader() {
        if (this.client.rpcVersion === 'v2') {
            return this.#getSigningHeaderRpcV2();
        }
        return this.#getSigningHeaderViaLegacyRpc();
    }
    async #getSigningHeaderRpcV2() {
        const api = this.client;
        // TODO similar to the legacy, we should account for the case finality is lagging behind
        const finalizedBlock = await api.chainHead.finalizedBlock();
        return {
            hash: finalizedBlock.hash,
            number: finalizedBlock.number,
        };
    }
    // Ref: https://github.com/polkadot-js/api/blob/3bdf49b0428a62f16b3222b9a31bfefa43c1ca55/packages/api-derive/src/tx/signingInfo.ts#L34-L64
    async #getSigningHeaderViaLegacyRpc() {
        const [header, finalizedHash] = await Promise.all([
            this.client.rpc.chain_getHeader(),
            this.client.rpc.chain_getFinalizedHead(),
        ]);
        (0, utils_1.assert)(header, 'Current header not found');
        const [currentHeader, finalizedHeader] = await Promise.all([
            Promise.resolve(header).then((header) => {
                const { parentHash } = header;
                if (parentHash.length === 0 || (0, utils_1.isZeroHex)(parentHash)) {
                    return header;
                }
                else {
                    return this.client.rpc.chain_getHeader(parentHash);
                }
            }),
            this.client.rpc.chain_getHeader(finalizedHash),
        ]);
        (0, utils_1.assert)(currentHeader, 'Cannot determine current header');
        if (!finalizedHeader || currentHeader.number - finalizedHeader.number > exports.MAX_FINALITY_LAG) {
            return this.#toSigningHeader(currentHeader);
        }
        return this.#toSigningHeader(finalizedHeader);
    }
    async #toSigningHeader(header) {
        const { number } = header;
        const hash = (await this.client.rpc.chain_getBlockHash(header.number));
        return { hash, number };
    }
    // Ref: https://github.com/polkadot-js/api/blob/3bdf49b0428a62f16b3222b9a31bfefa43c1ca55/packages/api-derive/src/tx/signingInfo.ts#L83-L93
    #calculateMortalLength() {
        return (0, utils_1.bnMin)(BigInt(this.#getConst('system', 'blockHashCount') || exports.FALLBACK_MAX_HASH_COUNT), BigInt(exports.MORTAL_PERIOD) /
            BigInt(this.#getConst('babe', 'expectedBlockTime') ||
                this.#getConst('aura', 'slotDuration') ||
                BigInt(this.#getConst('timestamp', 'minimumPeriod') || 0) * 2n ||
                exports.FALLBACK_PERIOD) +
            BigInt(exports.MAX_FINALITY_LAG));
    }
    #getConst(pallet, name) {
        try {
            return this.client.consts[pallet][name];
        }
        catch {
            // ignore this on purpose
        }
        return undefined;
    }
    toPayload() {
        return {
            era: (0, utils_1.u8aToHex)(this.$Data.tryEncode(this.data)),
            blockHash: this.additionalSigned,
            blockNumber: (0, utils_1.numberToHex)(this.#signingHeader.number),
        };
    }
}
exports.CheckMortality = CheckMortality;
