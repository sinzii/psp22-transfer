"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtraSignedExtension = void 0;
const $ = __importStar(require("@dedot/shape"));
const utils_1 = require("@dedot/utils");
const SignedExtension_js_1 = require("./SignedExtension.js");
const index_js_1 = require("./known/index.js");
class ExtraSignedExtension extends SignedExtension_js_1.SignedExtension {
    #signedExtensions;
    async init() {
        this.#signedExtensions = this.#getSignedExtensions();
        await Promise.all(this.#signedExtensions.map((se) => se.init()));
        this.data = this.#signedExtensions.map((se) => se.data);
        this.additionalSigned = this.#signedExtensions.map((se) => se.additionalSigned);
    }
    get identifier() {
        return 'ExtraSignedExtension';
    }
    get $Data() {
        const { extraTypeId } = this.registry.metadata.extrinsic;
        return (0, utils_1.ensurePresence)(this.registry.findCodec(extraTypeId));
    }
    get $AdditionalSigned() {
        const $AdditionalSignedCodecs = this.#signedExtensionDefs.map((se) => this.registry.findCodec(se.additionalSigned));
        return $.Tuple(...$AdditionalSignedCodecs);
    }
    get $Payload() {
        const { callTypeId } = this.registry.metadata.extrinsic;
        const $Call = this.registry.findCodec(callTypeId);
        return $.Tuple($Call, this.$Data, this.$AdditionalSigned);
    }
    get #signedExtensionDefs() {
        return this.registry.metadata.extrinsic.signedExtensions;
    }
    #getSignedExtensions() {
        return this.#signedExtensionDefs.map((extDef) => {
            const { signedExtensions: userSignedExtensions = {} } = this.client.options;
            const Extension = userSignedExtensions[extDef.ident] ||
                index_js_1.knownSignedExtensions[extDef.ident];
            (0, utils_1.assert)(Extension, `SignedExtension for ${extDef.ident} not found`);
            return new Extension(this.client, {
                ...(0, utils_1.ensurePresence)(this.options),
                def: extDef,
            });
        });
    }
    toPayload(call = '0x') {
        const signedExtensions = this.#signedExtensions.map((se) => se.identifier);
        const { version } = this.registry.metadata.extrinsic;
        return Object.assign({ address: this.options.signerAddress, signedExtensions, version, method: call }, ...this.#signedExtensions.map((se) => se.toPayload()));
    }
    toRawPayload(call = '0x') {
        const payload = this.toPayload(call);
        const $ToSignPayload = $.Tuple($.RawHex, this.$Data, this.$AdditionalSigned);
        const toSignPayload = [call, this.data, this.additionalSigned];
        const rawPayload = $ToSignPayload.tryEncode(toSignPayload);
        return {
            address: payload.address,
            data: (0, utils_1.u8aToHex)(rawPayload),
            type: 'payload',
        };
    }
}
exports.ExtraSignedExtension = ExtraSignedExtension;
