"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubmittableExtrinsic = void 0;
const utils_1 = require("@dedot/utils");
const BaseSubmittableExtrinsic_js_1 = require("./BaseSubmittableExtrinsic.js");
const SubmittableResult_js_1 = require("./SubmittableResult.js");
const utils_js_1 = require("./utils.js");
/**
 * @name SubmittableExtrinsic
 * @description A wrapper around an Extrinsic that exposes methods to sign, send, and other utility around Extrinsic.
 */
class SubmittableExtrinsic extends BaseSubmittableExtrinsic_js_1.BaseSubmittableExtrinsic {
    async dryRun(account, optionsOrHash) {
        const dryRunFn = this.client.rpc.system_dryRun;
        if ((0, utils_1.isHex)(optionsOrHash)) {
            return dryRunFn(this.toHex(), optionsOrHash);
        }
        await this.sign(account, optionsOrHash);
        return dryRunFn(this.toHex());
    }
    async send(callback) {
        const isSubscription = !!callback;
        const txHex = this.toHex();
        const txHash = this.hash;
        if (isSubscription) {
            return this.client.rpc.author_submitAndWatchExtrinsic(txHex, async (txStatus) => {
                if (txStatus.type === 'InBlock' || txStatus.type === 'Finalized') {
                    const blockHash = txStatus.value;
                    const [signedBlock, blockEvents] = await Promise.all([
                        this.client.rpc.chain_getBlock(blockHash),
                        this.getSystemEventsAt(blockHash),
                    ]);
                    const txIndex = signedBlock.block.extrinsics.indexOf(txHex);
                    (0, utils_1.assert)(txIndex >= 0, 'Extrinsic not found!');
                    const events = blockEvents.filter(({ phase }) => phase.type === 'ApplyExtrinsic' && phase.value === txIndex);
                    const blockNumber = signedBlock.block.header.number;
                    const status = (0, utils_js_1.toTxStatus)(txStatus, { txIndex, blockNumber });
                    return callback(new SubmittableResult_js_1.SubmittableResult({ status, txHash, events, txIndex }));
                }
                else {
                    const status = (0, utils_js_1.toTxStatus)(txStatus);
                    return callback(new SubmittableResult_js_1.SubmittableResult({ status, txHash }));
                }
            });
        }
        else {
            return this.client.rpc.author_submitExtrinsic(txHex);
        }
    }
}
exports.SubmittableExtrinsic = SubmittableExtrinsic;
