"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSubmittableExtrinsic = void 0;
const codecs_1 = require("@dedot/codecs");
const utils_1 = require("@dedot/utils");
const index_js_1 = require("../extensions/index.js");
const fakeSigner_js_1 = require("./fakeSigner.js");
const utils_js_1 = require("./utils.js");
class BaseSubmittableExtrinsic extends codecs_1.Extrinsic {
    client;
    #alterTx;
    constructor(client, call) {
        super(client.registry, call);
        this.client = client;
    }
    async paymentInfo(account, options) {
        await this.sign(account, { ...options, signer: fakeSigner_js_1.fakeSigner });
        const txU8a = this.toU8a();
        const api = this.client;
        return api.call.transactionPaymentApi.queryInfo(txU8a, txU8a.length);
    }
    async sign(fromAccount, options) {
        const address = (0, utils_js_1.isKeyringPair)(fromAccount) ? fromAccount.address : fromAccount.toString();
        const extra = new index_js_1.ExtraSignedExtension(this.client, {
            signerAddress: address,
            payloadOptions: options,
        });
        await extra.init();
        const signer = this.#getSigner(options);
        let signature, alteredTx;
        if ((0, utils_js_1.isKeyringPair)(fromAccount)) {
            signature = (0, utils_1.u8aToHex)((0, utils_js_1.signRaw)(fromAccount, extra.toRawPayload(this.callHex).data));
        }
        else if (signer?.signPayload) {
            const result = await signer.signPayload(extra.toPayload(this.callHex));
            signature = result.signature;
            alteredTx = result.signedTransaction;
        }
        else {
            throw new Error('Signer not found. Cannot sign the extrinsic!');
        }
        const { signatureTypeId } = this.registry.metadata.extrinsic;
        const $Signature = this.registry.findCodec(signatureTypeId);
        this.attachSignature({
            address: address,
            signature: $Signature.tryDecode(signature),
            extra: extra.data,
        });
        // If the tx payload are altered from signer
        // We'll need to validate the altered tx
        // and broadcast it instead of the original tx
        if (alteredTx) {
            this.#validateSignedTx(alteredTx);
            this.#alterTx = (0, utils_1.toHex)(alteredTx);
        }
        return this;
    }
    async signAndSend(fromAccount, partialOptions, maybeCallback) {
        const [options, callback] = this.#normalizeOptions(partialOptions, maybeCallback);
        await this.sign(fromAccount, options);
        return this.send(callback);
    }
    #normalizeOptions(partialOptions, callback) {
        if ((0, utils_1.isFunction)(partialOptions)) {
            return [{}, partialOptions];
        }
        else {
            return [Object.assign({}, partialOptions), callback];
        }
    }
    send(callback) {
        throw new Error('Unimplemented!');
    }
    async getSystemEventsAt(hash) {
        const atApi = (await this.client.at(hash));
        return await atApi.query.system.events();
    }
    toHex() {
        return this.#alterTx || super.toHex();
    }
    /**
     * Validate a raw signed transaction coming from signer
     * We need to make sure the tx is signed and call-data is intact/not-changing
     *
     * @param tx
     * @private
     */
    #validateSignedTx(tx) {
        const alteredTx = this.$Codec.tryDecode(tx);
        // The alter tx should be signed
        if (!alteredTx.signed) {
            throw new utils_1.DedotError('Altered transaction from signer is not signed');
        }
        // Signer's not allow the change the call data
        if (alteredTx.callHex !== this.callHex) {
            throw new utils_1.DedotError('Call data does not match, signer is not allowed to change tx call data.');
        }
    }
    #getSigner(options) {
        return options?.signer || this.client.options.signer;
    }
}
exports.BaseSubmittableExtrinsic = BaseSubmittableExtrinsic;
