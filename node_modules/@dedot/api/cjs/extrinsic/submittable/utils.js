"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toTxStatus = exports.signRaw = exports.isKeyringPair = void 0;
const utils_1 = require("@dedot/utils");
function isKeyringPair(account) {
    return (0, utils_1.isFunction)(account.sign);
}
exports.isKeyringPair = isKeyringPair;
/**
 * Sign a raw message
 * @param signerPair
 * @param raw
 */
function signRaw(signerPair, raw) {
    const u8a = (0, utils_1.hexToU8a)(raw);
    // Ref: https://github.com/paritytech/polkadot-sdk/blob/943697fa693a4da6ef481ef93df522accb7d0583/substrate/primitives/runtime/src/generic/unchecked_extrinsic.rs#L234-L238
    const toSignRaw = u8a.length > 256 ? (0, utils_1.blake2AsU8a)(u8a, 256) : u8a;
    return signerPair.sign(toSignRaw, { withType: true });
}
exports.signRaw = signRaw;
/**
 * Convert transaction status to transaction event
 *
 * Ref: https://github.com/paritytech/polkadot-sdk/blob/98a364fe6e7abf10819f5fddd3de0588f7c38700/substrate/client/rpc-spec-v2/src/transaction/transaction.rs#L132-L159
 * @param txStatus
 * @param txInfo
 */
function toTxStatus(txStatus, txInfo) {
    switch (txStatus.type) {
        case 'Ready':
        case 'Future':
            return { type: 'Validated' };
        case 'Broadcast':
            return { type: 'Broadcasting' };
        case 'Retracted':
            return { type: 'NoLongerInBestChain' };
        case 'InBlock':
            (0, utils_1.assert)(txInfo, 'TxInfo is required');
            return {
                type: 'BestChainBlockIncluded',
                value: {
                    blockHash: txStatus.value,
                    ...txInfo,
                },
            };
        case 'Finalized':
            (0, utils_1.assert)(txInfo, 'TxInfo is required');
            return {
                type: 'Finalized',
                value: {
                    blockHash: txStatus.value,
                    ...txInfo,
                },
            };
        case 'FinalityTimeout':
            return {
                type: 'Drop',
                value: {
                    error: 'Maximum number of finality watchers has been reached',
                },
            };
        case 'Dropped':
            return {
                type: 'Drop',
                value: {
                    error: 'Extrinsic dropped from the pool due to exceeding limits',
                },
            };
        case 'Usurped':
            return {
                type: 'Invalid',
                value: {
                    error: 'Extrinsic was rendered invalid by another extrinsic',
                },
            };
        case 'Invalid':
            return {
                type: 'Invalid',
                value: {
                    error: 'Extrinsic marked as invalid',
                },
            };
    }
}
exports.toTxStatus = toTxStatus;
