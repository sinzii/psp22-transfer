"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxExecutor = void 0;
const utils_1 = require("@dedot/utils");
const index_js_1 = require("../extrinsic/index.js");
const Executor_js_1 = require("./Executor.js");
/**
 * @name TxExecutor
 * @description Execute a transaction instruction, returns a submittable extrinsic
 */
class TxExecutor extends Executor_js_1.Executor {
    doExecute(pallet, functionName) {
        const targetPallet = this.getPallet(pallet);
        (0, utils_1.assert)(targetPallet.calls, new utils_1.UnknownApiError(`Tx calls are not available for pallet ${targetPallet.name}`));
        const txType = this.metadata.types[targetPallet.calls];
        (0, utils_1.assert)(txType.typeDef.type === 'Enum', new utils_1.UnknownApiError('Tx type defs should be enum'));
        const isFlatEnum = txType.typeDef.value.members.every((m) => m.fields.length === 0);
        const txCallDef = txType.typeDef.value.members.find((m) => (0, utils_1.stringCamelCase)(m.name) === functionName);
        (0, utils_1.assert)(txCallDef, new utils_1.UnknownApiError(`Tx call spec not found for ${pallet}.${functionName}`));
        const txCallFn = (...args) => {
            let call;
            if (isFlatEnum) {
                call = {
                    pallet: (0, utils_1.stringPascalCase)(targetPallet.name),
                    palletCall: (0, utils_1.stringPascalCase)(txCallDef.name),
                };
            }
            else {
                const callParams = txCallDef.fields.reduce((o, { name }, idx) => {
                    o[(0, utils_1.stringCamelCase)(name)] = args[idx];
                    return o;
                }, {});
                call = {
                    pallet: (0, utils_1.stringPascalCase)(targetPallet.name),
                    palletCall: {
                        name: (0, utils_1.stringPascalCase)(txCallDef.name),
                        params: callParams,
                    },
                };
            }
            return this.createExtrinsic(call);
        };
        txCallFn.meta = {
            ...txCallDef,
            fieldCodecs: txCallDef.fields.map(({ typeId }) => this.registry.findCodec(typeId)),
            pallet: targetPallet.name,
            palletIndex: targetPallet.index,
        };
        return txCallFn;
    }
    createExtrinsic(call) {
        return new index_js_1.SubmittableExtrinsic(this.client, call);
    }
}
exports.TxExecutor = TxExecutor;
