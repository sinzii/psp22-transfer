"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeApiExecutor = exports.FallbackRuntimeApiSpecs = exports.FallbackRuntimeApis = void 0;
const runtime_specs_1 = require("@dedot/runtime-specs");
const utils_1 = require("@dedot/utils");
const Executor_js_1 = require("./Executor.js");
exports.FallbackRuntimeApis = { '0x37e397fc7c91f5e4': 2 };
exports.FallbackRuntimeApiSpecs = { Metadata: runtime_specs_1.Metadata };
/**
 * @name RuntimeApiExecutor
 * @description Execute a runtime api call,
 * runtime api definitions/specs are either from Metadata V15
 * or defined externally when initializing `Dedot` instance
 * via `ApiOptions.runtimeApis` option.
 */
class RuntimeApiExecutor extends Executor_js_1.Executor {
    doExecute(runtimeApi, method) {
        const runtimeApiName = (0, utils_1.stringPascalCase)(runtimeApi);
        const methodName = (0, utils_1.stringSnakeCase)(method);
        const callName = this.#callName({ runtimeApiName, methodName });
        const callSpec = this.#findRuntimeApiMethodSpec(runtimeApiName, methodName);
        (0, utils_1.assert)(callSpec, new utils_1.UnknownApiError(`Runtime api spec not found for ${callName}`));
        const callFn = async (...args) => {
            const { params } = callSpec;
            const formattedInputs = params.map((param, index) => this.tryEncode(param, args[index]));
            const bytes = (0, utils_1.u8aToHex)((0, utils_1.concatU8a)(...formattedInputs));
            const callParams = {
                func: callName,
                params: bytes,
                at: this.atBlockHash,
            };
            const result = await this.stateCall(callParams);
            return this.tryDecode(callSpec, result);
        };
        callFn.meta = callSpec;
        return callFn;
    }
    stateCall(callParams) {
        const { func, params, at } = callParams;
        const args = [func, params];
        if (at)
            args.push(at);
        return this.client.rpc.state_call(...args);
    }
    tryDecode(callSpec, raw) {
        const $codec = this.#findCodec(callSpec, `Codec not found to decode respond data for ${this.#callName(callSpec)}`);
        return $codec.tryDecode(raw);
    }
    tryEncode(paramSpec, value) {
        const $codec = this.#findCodec(paramSpec, `Codec not found to encode input for param ${paramSpec.name}`);
        return $codec.tryEncode(value);
    }
    #findCodec(spec, error) {
        const { codec, typeId, type } = spec;
        if (codec)
            return codec;
        if ((0, utils_1.isNumber)(typeId)) {
            return this.registry.findCodec(typeId);
        }
        throw new Error(error || 'Codec not found');
    }
    #callName({ runtimeApiName, methodName }) {
        return `${runtimeApiName}_${methodName}`;
    }
    #findRuntimeApiMethodSpec(runtimeApi, method) {
        const targetVersion = this.#findTargetRuntimeApiVersion(runtimeApi);
        if (!(0, utils_1.isNumber)(targetVersion))
            return undefined;
        const userDefinedSpec = this.#findDefinedSpec(this.client.options.runtimeApis, runtimeApi, method, targetVersion);
        if (userDefinedSpec)
            return userDefinedSpec;
        const methodDef = this.#findRuntimeApiMethodDef(runtimeApi, method);
        if (methodDef) {
            return this.#toMethodSpec(runtimeApi, methodDef);
        }
        return this.#findDefinedSpec(exports.FallbackRuntimeApiSpecs, runtimeApi, method, targetVersion);
    }
    #findRuntimeApiMethodDef(runtimeApi, method) {
        try {
            for (const api of this.metadata.apis) {
                if (api.name !== runtimeApi)
                    continue;
                for (const apiMethod of api.methods) {
                    if (apiMethod.name === method)
                        return apiMethod;
                }
            }
        }
        catch { }
    }
    #toMethodSpec(runtimeApi, methodDef) {
        const { name, inputs, output, docs } = methodDef;
        return {
            docs,
            runtimeApiName: runtimeApi,
            methodName: name,
            typeId: output,
            params: inputs.map(({ name, typeId }) => ({
                name,
                typeId,
            })),
        };
    }
    #findTargetRuntimeApiVersion(runtimeApi) {
        const runtimeApiHash = (0, utils_1.calcRuntimeApiHash)(runtimeApi);
        try {
            return this.client.runtimeVersion.apis[runtimeApiHash] || exports.FallbackRuntimeApis[runtimeApiHash];
        }
        catch {
            return exports.FallbackRuntimeApis[runtimeApiHash];
        }
    }
    #findDefinedSpec(specs, runtimeApi, method, runtimeApiVersion) {
        if (!specs)
            return undefined;
        const methodSpecs = (0, runtime_specs_1.toRuntimeApiSpecs)(specs).map(runtime_specs_1.toRuntimeApiMethods).flat();
        return methodSpecs.find(({ runtimeApiName, methodName, version }) => `${(0, utils_1.stringPascalCase)(runtimeApiName)}_${(0, utils_1.stringSnakeCase)(methodName)}` === `${runtimeApi}_${method}` &&
            runtimeApiVersion === version);
    }
}
exports.RuntimeApiExecutor = RuntimeApiExecutor;
