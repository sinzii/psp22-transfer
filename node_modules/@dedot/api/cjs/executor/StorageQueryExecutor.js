"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageQueryExecutor = void 0;
const utils_1 = require("@dedot/utils");
const QueryableStorage_js_1 = require("../storage/QueryableStorage.js");
const Executor_js_1 = require("./Executor.js");
const DEFAULT_KEYS_PAGE_SIZE = 1000;
const DEFAULT_ENTRIES_PAGE_SIZE = 250;
/**
 * @name StorageQueryExecutor
 * @description Execute a query to on-chain storage
 */
class StorageQueryExecutor extends Executor_js_1.Executor {
    doExecute(pallet, storage) {
        const entry = new QueryableStorage_js_1.QueryableStorage(this.registry, pallet, storage);
        const extractArgs = (args) => {
            const inArgs = args.slice();
            const lastArg = args.at(-1);
            const callback = (0, utils_1.isFunction)(lastArg) ? inArgs.pop() : undefined;
            return [inArgs, callback];
        };
        const getStorageKey = (...args) => {
            const [inArgs] = extractArgs(args);
            return entry.encodeKey(inArgs.at(0));
        };
        const getStorage = async (keys) => {
            const results = await this.queryStorage(keys, this.atBlockHash);
            return keys.reduce((o, key) => {
                o[key] = entry.decodeValue(results[key]);
                return o;
            }, {});
        };
        const queryFn = async (...args) => {
            const [inArgs, callback] = extractArgs(args);
            const encodedKey = entry.encodeKey(inArgs.at(0));
            // if a callback is passed, make a storage subscription and return an unsub function
            if (callback) {
                return await this.subscribeStorage([encodedKey], (changes) => {
                    if (changes.length === 0)
                        return;
                    callback(entry.decodeValue(changes[0]));
                });
            }
            else {
                const results = await getStorage([encodedKey]);
                return results[encodedKey];
            }
        };
        queryFn.rawKey = getStorageKey;
        queryFn.meta = {
            pallet: entry.pallet.name,
            palletIndex: entry.pallet.index,
            ...entry.storageEntry,
        };
        const isMap = entry.storageEntry.storageType.type === 'Map';
        if (isMap) {
            const queryMultiFn = async (...args) => {
                const [inArgs, callback] = extractArgs(args);
                const multiArgs = inArgs.at(0);
                (0, utils_1.assert)(Array.isArray(multiArgs), 'First param for multi query should be an array');
                const encodedKeys = multiArgs.map((arg) => entry.encodeKey(arg));
                // if a callback is passed, make a storage subscription and return an unsub function
                if (callback) {
                    return await this.subscribeStorage(encodedKeys, (changes) => {
                        callback(changes.map((change) => entry.decodeValue(change)));
                    });
                }
                else {
                    const result = await getStorage(encodedKeys);
                    return encodedKeys.map((key) => result[key]);
                }
            };
            // @ts-ignore
            queryFn.multi = queryMultiFn;
            Object.assign(queryFn, this.exposeStorageMapMethods(entry));
        }
        return queryFn;
    }
    exposeStorageMapMethods(entry) {
        const rawKeys = async (pagination) => {
            const pageSize = pagination?.pageSize || DEFAULT_KEYS_PAGE_SIZE;
            const startKey = pagination?.startKey || entry.prefixKey;
            return await this.client.rpc.state_getKeysPaged(entry.prefixKey, pageSize, startKey, this.atBlockHash);
        };
        const pagedKeys = async (pagination) => {
            const storageKeys = await rawKeys({ pageSize: DEFAULT_KEYS_PAGE_SIZE, ...pagination });
            return storageKeys.map((key) => entry.decodeKey(key));
        };
        const pagedEntries = async (pagination) => {
            const storageKeys = await rawKeys({ pageSize: DEFAULT_ENTRIES_PAGE_SIZE, ...pagination });
            const storageMap = await this.queryStorage(storageKeys, this.atBlockHash);
            return storageKeys.map((key) => [entry.decodeKey(key), entry.decodeValue(storageMap[key])]);
        };
        return { pagedKeys, pagedEntries };
    }
    async queryStorage(keys, hash) {
        const changeSets = await this.client.rpc.state_queryStorageAt(keys, hash);
        return changeSets[0].changes.reduce((o, [key, value]) => {
            o[key] = value ?? undefined;
            return o;
        }, {});
    }
    subscribeStorage(keys, callback) {
        const lastChanges = {};
        return this.client.rpc.state_subscribeStorage(keys, (changeSet) => {
            changeSet.changes.forEach(([key, value]) => {
                if (lastChanges[key] !== value) {
                    lastChanges[key] = value ?? undefined;
                }
            });
            return callback(keys.map((key) => lastChanges[key]));
        });
    }
}
exports.StorageQueryExecutor = StorageQueryExecutor;
