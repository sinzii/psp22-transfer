"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DedotClient = void 0;
const codecs_1 = require("@dedot/codecs");
const shape_1 = require("@dedot/shape");
const utils_1 = require("@dedot/utils");
const index_js_1 = require("../executor/index.js");
const index_js_2 = require("../json-rpc/index.js");
const proxychain_js_1 = require("../proxychain.js");
const BaseSubstrateClient_js_1 = require("./BaseSubstrateClient.js");
/**
 * @name DedotClient
 * @description New promised-based API Client for Polkadot & Substrate based on JSON-RPC V2
 *
 * __Unstable, use with caution.__
 */
class DedotClient// prettier-end-here
 extends BaseSubstrateClient_js_1.BaseSubstrateClient {
    _chainHead;
    _chainSpec;
    _txBroadcaster;
    #apiAtCache = {};
    /**
     * Use factory methods (`create`, `new`) to create `DedotClient` instances.
     *
     * @param options
     */
    constructor(options) {
        super('v2', options);
    }
    /**
     * Factory method to create a new DedotClient instance
     *
     * @param options
     */
    static async create(options) {
        return new DedotClient(options).connect();
    }
    /**
     * Alias for __DedotClient.create__
     *
     * @param options
     */
    static async new(options) {
        return DedotClient.create(options);
    }
    get chainSpec() {
        return (0, BaseSubstrateClient_js_1.ensurePresence)(this._chainSpec);
    }
    get chainHead() {
        return (0, BaseSubstrateClient_js_1.ensurePresence)(this._chainHead);
    }
    get txBroadcaster() {
        this.chainHead; // Ensure chain head is initialized
        (0, utils_1.assert)(this._txBroadcaster, 'JSON-RPC method to broadcast transactions is not supported by the server/node.');
        return this._txBroadcaster;
    }
    async #initializeTxBroadcaster(rpcMethods) {
        const tx = new index_js_2.Transaction(this, { rpcMethods });
        if (await tx.supported())
            return tx;
        const txWatch = new index_js_2.TransactionWatch(this, { rpcMethods });
        if (await txWatch.supported())
            return txWatch;
    }
    /**
     * Initialize APIs before usage
     */
    async doInitialize() {
        const rpcMethods = (await this.rpc.rpc_methods()).methods;
        this._chainHead = new index_js_2.ChainHead(this, { rpcMethods });
        this._chainSpec = new index_js_2.ChainSpec(this, { rpcMethods });
        this._txBroadcaster = await this.#initializeTxBroadcaster(rpcMethods);
        // Fetching node information
        let [_, genesisHash] = await Promise.all([
            this.chainHead.follow(),
            this.chainSpec.genesisHash().catch(() => undefined),
        ]);
        this._genesisHash = genesisHash || (await this.#getGenesisHashFallback());
        this._runtimeVersion = await this.chainHead.bestRuntimeVersion();
        let metadata;
        if (await this.shouldPreloadMetadata()) {
            metadata = await this.fetchMetadata();
        }
        await this.setupMetadata(metadata);
        this.subscribeRuntimeUpgrades();
    }
    /**
     * Ref: https://github.com/paritytech/polkadot-sdk/blob/bbd51ce867967f71657b901f1a956ad4f75d352e/substrate/frame/system/src/lib.rs#L909-L913
     * @private
     */
    async #getGenesisHashFallback() {
        const pallet = (0, utils_1.xxhashAsU8a)('System', 128);
        const item = (0, utils_1.xxhashAsU8a)('BlockHash', 128);
        const blockHeightAt0 = (0, utils_1.twox64Concat)(shape_1.u32.encode(0));
        const key = (0, utils_1.u8aToHex)((0, utils_1.concatU8a)(pallet, item, blockHeightAt0));
        const storageValue = await this.chainHead.storage([{ type: 'value', key }]);
        const rawGenesisHash = storageValue.at(0)?.value;
        (0, utils_1.assert)(rawGenesisHash, 'Genesis hash not found!');
        // Here we assume that in most case the hash is stored as a H256
        return codecs_1.$H256.tryDecode(rawGenesisHash);
    }
    subscribeRuntimeUpgrades() {
        this.chainHead.on('bestBlock', this.onRuntimeUpgrade);
    }
    onRuntimeUpgrade = async (block) => {
        const runtimeUpgraded = block.runtime && block.runtime.specVersion !== this._runtimeVersion?.specVersion;
        if (!runtimeUpgraded)
            return;
        this.startRuntimeUpgrade();
        this._runtimeVersion = block.runtime;
        const newMetadata = await this.fetchMetadata(undefined, this._runtimeVersion);
        await this.setupMetadata(newMetadata);
        this.emit('runtimeUpgraded', this._runtimeVersion);
        this.doneRuntimeUpgrade();
    };
    async beforeDisconnect() {
        await this.chainHead.unfollow();
    }
    onDisconnected = async () => {
        this.chainHead.unfollow().catch(utils_1.noop);
    };
    cleanUp() {
        super.cleanUp();
        this._chainHead = undefined;
        this._chainSpec = undefined;
        this._txBroadcaster = undefined;
        this.#apiAtCache = {};
    }
    get query() {
        return (0, proxychain_js_1.newProxyChain)({
            executor: new index_js_1.StorageQueryExecutorV2(this, this.chainHead),
        });
    }
    get call() {
        return this.callAt();
    }
    callAt(blockHash) {
        return (0, proxychain_js_1.newProxyChain)({
            executor: new index_js_1.RuntimeApiExecutorV2(this, this.chainHead, blockHash),
        });
    }
    get tx() {
        return (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.TxExecutorV2(this) });
    }
    /**
     * Get a new API instance at a specific block hash
     * For now, this only supports pinned block hashes from the chain head
     *
     * @param hash
     */
    async at(hash) {
        if (this.#apiAtCache[hash])
            return this.#apiAtCache[hash];
        const targetBlock = this.chainHead.findBlock(hash);
        (0, utils_1.assert)(targetBlock, 'Block is not pinned!');
        let targetVersion = targetBlock.runtime;
        if (!targetVersion) {
            // fallback to fetching on-chain runtime if we can't find it in the block
            targetVersion = this.toSubstrateRuntimeVersion(await this.callAt(hash).core.version());
        }
        let metadata = this.metadata;
        let registry = this.registry;
        if (targetVersion && targetVersion.specVersion !== this.runtimeVersion.specVersion) {
            metadata = await this.fetchMetadata(hash, targetVersion);
            registry = new codecs_1.PortableRegistry(metadata.latest, this.options.hasher);
        }
        const api = {
            rpcVersion: 'v2',
            atBlockHash: hash,
            options: this.options,
            genesisHash: this.genesisHash,
            runtimeVersion: targetVersion,
            metadata,
            registry,
            rpc: this.rpc,
        };
        api.consts = (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.ConstantExecutor(api) });
        api.events = (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.EventExecutor(api) });
        api.errors = (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.ErrorExecutor(api) });
        api.query = (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.StorageQueryExecutorV2(api, this.chainHead) });
        api.call = (0, proxychain_js_1.newProxyChain)({ executor: new index_js_1.RuntimeApiExecutorV2(api, this.chainHead) });
        this.#apiAtCache[hash] = api;
        return api;
    }
}
exports.DedotClient = DedotClient;
