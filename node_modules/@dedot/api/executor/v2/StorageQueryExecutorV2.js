import { assert } from '@dedot/utils';
import { StorageQueryExecutor } from '../StorageQueryExecutor.js';
/**
 * @name StorageQueryExecutorV2
 */
export class StorageQueryExecutorV2 extends StorageQueryExecutor {
    chainHead;
    constructor(client, chainHead, atBlockHash) {
        assert(client.rpcVersion === 'v2', 'Only supports JSON-RPC v2');
        super(client, atBlockHash);
        this.chainHead = chainHead;
    }
    exposeStorageMapMethods(entry) {
        // chainHead_storage does not support pagination
        // so for now we're trying to pull all entries from storage
        // this might take a while for large storage
        // TODO improve this, fallback to use `archive`-prefixed if available?
        const entries = async () => {
            const results = await this.chainHead.storage([{ type: 'descendantsValues', key: entry.prefixKey }]);
            return results.map(({ key, value }) => [
                entry.decodeKey(key),
                entry.decodeValue(value),
            ]);
        };
        return { entries };
    }
    async queryStorage(keys, at) {
        const results = await this.chainHead.storage(keys.map((key) => ({ type: 'value', key })), undefined, at);
        return results.reduce((o, r) => {
            o[r.key] = (r.value ?? undefined);
            return o;
        }, {});
    }
    async subscribeStorage(keys, callback) {
        let best = await this.chainHead.bestBlock();
        let eventToListen = 'bestBlock';
        // TODO subscribe to finalized data source
        // initialHash = this.chainHead.finalizedHash;
        // eventToListen = 'finalizedBlock';
        const latestChanges = new Map();
        const pull = async ({ hash }) => {
            const results = await this.queryStorage(keys, hash);
            let changed = false;
            keys.forEach((key) => {
                const newValue = results[key];
                if (latestChanges.size > 0 && latestChanges.get(key) === newValue)
                    return;
                changed = true;
                latestChanges.set(key, newValue);
            });
            if (!changed)
                return;
            callback(keys.map((key) => latestChanges.get(key)));
        };
        await pull(best);
        const unsub = this.chainHead.on(eventToListen, pull);
        return async () => {
            unsub();
        };
    }
}
