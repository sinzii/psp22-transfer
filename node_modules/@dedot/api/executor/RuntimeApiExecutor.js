import { Metadata, toRuntimeApiMethods, toRuntimeApiSpecs } from '@dedot/runtime-specs';
import { assert, calcRuntimeApiHash, concatU8a, isNumber, stringPascalCase, stringSnakeCase, u8aToHex, UnknownApiError, } from '@dedot/utils';
import { Executor } from './Executor.js';
export const FallbackRuntimeApis = { '0x37e397fc7c91f5e4': 2 };
export const FallbackRuntimeApiSpecs = { Metadata };
/**
 * @name RuntimeApiExecutor
 * @description Execute a runtime api call,
 * runtime api definitions/specs are either from Metadata V15
 * or defined externally when initializing `Dedot` instance
 * via `ApiOptions.runtimeApis` option.
 */
export class RuntimeApiExecutor extends Executor {
    doExecute(runtimeApi, method) {
        const runtimeApiName = stringPascalCase(runtimeApi);
        const methodName = stringSnakeCase(method);
        const callName = this.#callName({ runtimeApiName, methodName });
        const callSpec = this.#findRuntimeApiMethodSpec(runtimeApiName, methodName);
        assert(callSpec, new UnknownApiError(`Runtime api spec not found for ${callName}`));
        const callFn = async (...args) => {
            const { params } = callSpec;
            const formattedInputs = params.map((param, index) => this.tryEncode(param, args[index]));
            const bytes = u8aToHex(concatU8a(...formattedInputs));
            const callParams = {
                func: callName,
                params: bytes,
                at: this.atBlockHash,
            };
            const result = await this.stateCall(callParams);
            return this.tryDecode(callSpec, result);
        };
        callFn.meta = callSpec;
        return callFn;
    }
    stateCall(callParams) {
        const { func, params, at } = callParams;
        const args = [func, params];
        if (at)
            args.push(at);
        return this.client.rpc.state_call(...args);
    }
    tryDecode(callSpec, raw) {
        const $codec = this.#findCodec(callSpec, `Codec not found to decode respond data for ${this.#callName(callSpec)}`);
        return $codec.tryDecode(raw);
    }
    tryEncode(paramSpec, value) {
        const $codec = this.#findCodec(paramSpec, `Codec not found to encode input for param ${paramSpec.name}`);
        return $codec.tryEncode(value);
    }
    #findCodec(spec, error) {
        const { codec, typeId, type } = spec;
        if (codec)
            return codec;
        if (isNumber(typeId)) {
            return this.registry.findCodec(typeId);
        }
        throw new Error(error || 'Codec not found');
    }
    #callName({ runtimeApiName, methodName }) {
        return `${runtimeApiName}_${methodName}`;
    }
    #findRuntimeApiMethodSpec(runtimeApi, method) {
        const targetVersion = this.#findTargetRuntimeApiVersion(runtimeApi);
        if (!isNumber(targetVersion))
            return undefined;
        const userDefinedSpec = this.#findDefinedSpec(this.client.options.runtimeApis, runtimeApi, method, targetVersion);
        if (userDefinedSpec)
            return userDefinedSpec;
        const methodDef = this.#findRuntimeApiMethodDef(runtimeApi, method);
        if (methodDef) {
            return this.#toMethodSpec(runtimeApi, methodDef);
        }
        return this.#findDefinedSpec(FallbackRuntimeApiSpecs, runtimeApi, method, targetVersion);
    }
    #findRuntimeApiMethodDef(runtimeApi, method) {
        try {
            for (const api of this.metadata.apis) {
                if (api.name !== runtimeApi)
                    continue;
                for (const apiMethod of api.methods) {
                    if (apiMethod.name === method)
                        return apiMethod;
                }
            }
        }
        catch { }
    }
    #toMethodSpec(runtimeApi, methodDef) {
        const { name, inputs, output, docs } = methodDef;
        return {
            docs,
            runtimeApiName: runtimeApi,
            methodName: name,
            typeId: output,
            params: inputs.map(({ name, typeId }) => ({
                name,
                typeId,
            })),
        };
    }
    #findTargetRuntimeApiVersion(runtimeApi) {
        const runtimeApiHash = calcRuntimeApiHash(runtimeApi);
        try {
            return this.client.runtimeVersion.apis[runtimeApiHash] || FallbackRuntimeApis[runtimeApiHash];
        }
        catch {
            return FallbackRuntimeApis[runtimeApiHash];
        }
    }
    #findDefinedSpec(specs, runtimeApi, method, runtimeApiVersion) {
        if (!specs)
            return undefined;
        const methodSpecs = toRuntimeApiSpecs(specs).map(toRuntimeApiMethods).flat();
        return methodSpecs.find(({ runtimeApiName, methodName, version }) => `${stringPascalCase(runtimeApiName)}_${stringSnakeCase(methodName)}` === `${runtimeApi}_${method}` &&
            runtimeApiVersion === version);
    }
}
