import { Signer } from '@polkadot/types/types';
import { BlockHash, Hash, Metadata, PortableRegistry, RuntimeVersion } from '@dedot/codecs';
import type { JsonRpcProvider } from '@dedot/providers';
import { type IStorage } from '@dedot/storage';
import { GenericSubstrateApi, RpcVersion, VersionedGenericSubstrateApi } from '@dedot/types';
import { Deferred } from '@dedot/utils';
import type { SubstrateApi } from '../chaintypes/index.js';
import { JsonRpcClient } from '../json-rpc/index.js';
import type { ApiEvent, ApiOptions, ISubstrateClient, ISubstrateClientAt, JsonRpcClientOptions, MetadataKey, SubstrateRuntimeVersion } from '../types.js';
export declare function ensurePresence<T>(value: T): NonNullable<T>;
/**
 * @name BaseSubstrateClient
 * @description Base & shared abstraction for Substrate API Clients
 */
export declare abstract class BaseSubstrateClient<Rv extends RpcVersion, ChainApi extends VersionedGenericSubstrateApi = SubstrateApi> extends JsonRpcClient<ChainApi, ApiEvent> implements ISubstrateClient<ChainApi[Rv]> {
    rpcVersion: RpcVersion;
    protected _options: ApiOptions;
    protected _registry?: PortableRegistry;
    protected _metadata?: Metadata;
    protected _genesisHash?: Hash;
    protected _runtimeVersion?: SubstrateRuntimeVersion;
    protected _localCache?: IStorage;
    protected _runtimeUpgrading?: Deferred<void>;
    protected constructor(rpcVersion: RpcVersion, options: JsonRpcClientOptions | JsonRpcProvider);
    protected normalizeOptions(options: ApiOptions | JsonRpcProvider): ApiOptions;
    protected initializeLocalCache(): Promise<void>;
    protected setupMetadata(preloadMetadata: Metadata | undefined): Promise<void>;
    protected setMetadata(metadata: Metadata): void;
    protected getMetadataKey(runtime?: SubstrateRuntimeVersion): MetadataKey;
    get currentMetadataKey(): string;
    protected shouldPreloadMetadata(): Promise<boolean>;
    protected getMetadataFromOptions(runtime?: SubstrateRuntimeVersion): Metadata | undefined;
    protected fetchMetadata(hash?: BlockHash, runtime?: SubstrateRuntimeVersion): Promise<Metadata>;
    protected cleanUp(): void;
    /**
     * @description Clear local cache
     */
    clearCache(): Promise<void>;
    protected doConnect(): Promise<this>;
    protected onConnected: () => Promise<void>;
    protected onDisconnected: () => Promise<void>;
    protected initialize(): Promise<void>;
    protected doInitialize(): Promise<void>;
    protected beforeDisconnect(): Promise<void>;
    protected afterDisconnect(): Promise<void>;
    protected toSubstrateRuntimeVersion(runtimeVersion: RuntimeVersion): SubstrateRuntimeVersion;
    protected startRuntimeUpgrade(): void;
    protected doneRuntimeUpgrade(): void;
    protected ensureRuntimeUpgraded(): Promise<void>;
    /**
     * @description Connect to blockchain node
     */
    connect(): Promise<this>;
    /**
     * @description Disconnect to blockchain node
     */
    disconnect(): Promise<void>;
    get options(): ApiOptions;
    get metadata(): Metadata;
    get registry(): PortableRegistry;
    get genesisHash(): Hash;
    get runtimeVersion(): SubstrateRuntimeVersion;
    getRuntimeVersion(): Promise<SubstrateRuntimeVersion>;
    get consts(): ChainApi[Rv]['consts'];
    get errors(): ChainApi[Rv]['errors'];
    get events(): ChainApi[Rv]['events'];
    get query(): ChainApi[Rv]['query'];
    get call(): ChainApi[Rv]['call'];
    protected callAt(hash?: BlockHash): ChainApi[Rv]['call'];
    get tx(): ChainApi[Rv]['tx'];
    at<ChainApiAt extends GenericSubstrateApi = ChainApi[Rv]>(hash: BlockHash): Promise<ISubstrateClientAt<ChainApiAt>>;
    setSigner(signer?: Signer): void;
}
