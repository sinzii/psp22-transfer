import { $Metadata, PortableRegistry } from '@dedot/codecs';
import { LocalStorage } from '@dedot/storage';
import { calcRuntimeApiHash, deferred, ensurePresence as _ensurePresence, u8aToHex } from '@dedot/utils';
import { ConstantExecutor, ErrorExecutor, EventExecutor } from '../executor/index.js';
import { isJsonRpcProvider, JsonRpcClient } from '../json-rpc/index.js';
import { newProxyChain } from '../proxychain.js';
const SUPPORTED_METADATA_VERSIONS = [15, 14];
const MetadataApiHash = calcRuntimeApiHash('Metadata'); // 0x37e397fc7c91f5e4
const MESSAGE = 'Make sure to call `.connect()` method first before using the API interfaces.';
export function ensurePresence(value) {
    return _ensurePresence(value, MESSAGE);
}
/**
 * @name BaseSubstrateClient
 * @description Base & shared abstraction for Substrate API Clients
 */
export class BaseSubstrateClient extends JsonRpcClient {
    rpcVersion;
    _options;
    _registry;
    _metadata;
    _genesisHash;
    _runtimeVersion;
    _localCache;
    _runtimeUpgrading;
    constructor(rpcVersion, options) {
        super(options);
        this.rpcVersion = rpcVersion;
        this._options = this.normalizeOptions(options);
    }
    /// --- Internal logics
    normalizeOptions(options) {
        const defaultOptions = { throwOnUnknownApi: true };
        if (isJsonRpcProvider(options)) {
            return { ...defaultOptions, provider: options };
        }
        else {
            return { ...defaultOptions, ...options };
        }
    }
    async initializeLocalCache() {
        if (!this._options.cacheMetadata)
            return;
        // Initialize local cache
        if (this._options.cacheStorage) {
            this._localCache = this._options.cacheStorage;
            return;
        }
        try {
            this._localCache = new LocalStorage();
        }
        catch {
            throw new Error('localStorage is not available for caching, please provide a cacheStorage option');
        }
    }
    async setupMetadata(preloadMetadata) {
        let metadata = preloadMetadata;
        let shouldUpdateCache = !!metadata;
        if (!metadata) {
            metadata = this.getMetadataFromOptions(this._runtimeVersion);
        }
        const metadataKey = this.currentMetadataKey;
        try {
            if (this._localCache && this._options.cacheMetadata) {
                if (!metadata) {
                    try {
                        const cachedRawMetadata = await this._localCache.get(metadataKey);
                        if (cachedRawMetadata) {
                            metadata = $Metadata.tryDecode(cachedRawMetadata);
                        }
                    }
                    catch (e) {
                        console.error('Cannot decode raw metadata, try fetching fresh metadata from chain.', e);
                    }
                }
            }
        }
        finally {
            if (!metadata) {
                metadata = await this.fetchMetadata();
                if (this._options.cacheMetadata)
                    shouldUpdateCache = true;
            }
        }
        if (shouldUpdateCache && this._localCache) {
            await this._localCache.set(metadataKey, u8aToHex($Metadata.tryEncode(metadata)));
        }
        if (!metadata) {
            throw new Error('Cannot load metadata');
        }
        this.setMetadata(metadata);
    }
    setMetadata(metadata) {
        this._metadata = metadata;
        this._registry = new PortableRegistry(metadata.latest, this.options.hasher);
    }
    getMetadataKey(runtime) {
        return `RAW_META/${this._genesisHash || '0x'}/${runtime?.specVersion || '---'}`;
    }
    get currentMetadataKey() {
        return this.getMetadataKey(this._runtimeVersion);
    }
    async shouldPreloadMetadata() {
        if (this._options.metadata && Object.keys(this._options.metadata).length) {
            return false;
        }
        if (!this._options.cacheMetadata || !this._localCache) {
            return true;
        }
        // TODO improve this
        const keys = await this._localCache.keys();
        return !keys.some((k) => k.startsWith('RAW_META/'));
    }
    getMetadataFromOptions(runtime) {
        if (!runtime || !this.options.metadata)
            return;
        const key = this.getMetadataKey(runtime);
        if (this.options.metadata[key]) {
            return $Metadata.tryDecode(this.options.metadata[key]);
        }
    }
    async fetchMetadata(hash, runtime) {
        // First try finding metadata from the provided option
        const optionMetadata = this.getMetadataFromOptions(runtime);
        if (optionMetadata)
            return optionMetadata;
        // If there is no runtime, we assume that the node supports Metadata Api V2
        const supportedV2 = runtime ? runtime.apis[MetadataApiHash] === 2 : true;
        if (supportedV2) {
            // It makes sense to call metadata.metadataVersions to fetch the list of supported metadata versions first
            // But for now, this approach could potentially help save/reduce one rpc call to the server in case the node support v15
            // Question: Why not having a `metadata.metadataLatest` to fetch the latest version?
            for (const version of SUPPORTED_METADATA_VERSIONS) {
                try {
                    const rawMetadata = await this.callAt(hash).metadata.metadataAtVersion(version);
                    if (!rawMetadata)
                        continue;
                    return $Metadata.tryDecode(rawMetadata);
                }
                catch { }
            }
        }
        try {
            return $Metadata.tryDecode(await this.callAt(hash).metadata.metadata());
        }
        catch {
            return await this.rpc.state_getMetadata();
        }
    }
    cleanUp() {
        this._registry = undefined;
        this._metadata = undefined;
        this._genesisHash = undefined;
        this._runtimeVersion = undefined;
        this._localCache = undefined;
    }
    /**
     * @description Clear local cache
     */
    async clearCache() {
        await this._localCache?.clear();
    }
    async doConnect() {
        this.on('connected', this.onConnected);
        this.on('disconnected', this.onDisconnected);
        return new Promise((resolve) => {
            this.once('ready', () => {
                resolve(this);
            });
        });
    }
    onConnected = async () => {
        await this.initialize();
    };
    onDisconnected = async () => { };
    async initialize() {
        await this.initializeLocalCache();
        await this.doInitialize();
        this.emit('ready');
    }
    async doInitialize() {
        throw new Error('Unimplemented!');
    }
    async beforeDisconnect() { }
    async afterDisconnect() {
        this.cleanUp();
    }
    toSubstrateRuntimeVersion(runtimeVersion) {
        return {
            ...runtimeVersion,
            apis: runtimeVersion.apis.reduce((o, [name, version]) => {
                o[name] = version;
                return o;
            }, {}),
        };
    }
    startRuntimeUpgrade() {
        this._runtimeUpgrading = deferred();
    }
    doneRuntimeUpgrade() {
        if (!this._runtimeUpgrading)
            return;
        this._runtimeUpgrading.resolve();
        setTimeout(() => {
            this._runtimeUpgrading = undefined;
        });
    }
    async ensureRuntimeUpgraded() {
        if (!this._runtimeUpgrading)
            return;
        await this._runtimeUpgrading.promise;
    }
    /// --- Public APIs ---
    /**
     * @description Connect to blockchain node
     */
    async connect() {
        const [api, _] = await Promise.all([this.doConnect(), super.connect()]);
        return api;
    }
    /**
     * @description Disconnect to blockchain node
     */
    async disconnect() {
        await this.beforeDisconnect();
        await super.disconnect();
        await this.afterDisconnect();
    }
    get options() {
        return this._options;
    }
    get metadata() {
        return ensurePresence(this._metadata);
    }
    get registry() {
        return ensurePresence(this._registry);
    }
    get genesisHash() {
        return ensurePresence(this._genesisHash);
    }
    get runtimeVersion() {
        return ensurePresence(this._runtimeVersion);
    }
    async getRuntimeVersion() {
        await this.ensureRuntimeUpgraded();
        return this.runtimeVersion;
    }
    get consts() {
        return newProxyChain({ executor: new ConstantExecutor(this) });
    }
    get errors() {
        return newProxyChain({ executor: new ErrorExecutor(this) });
    }
    get events() {
        return newProxyChain({ executor: new EventExecutor(this) });
    }
    get query() {
        throw new Error('Unimplemented!');
    }
    get call() {
        return this.callAt();
    }
    // For internal use with caution
    callAt(hash) {
        throw new Error('Unimplemented!');
    }
    get tx() {
        throw new Error('Unimplemented!');
    }
    at(hash) {
        throw new Error('Unimplemented!');
    }
    setSigner(signer) {
        this._options.signer = signer;
    }
}
