import { $H256, PortableRegistry } from '@dedot/codecs';
import { u32 } from '@dedot/shape';
import { assert, concatU8a, noop, twox64Concat, u8aToHex, xxhashAsU8a } from '@dedot/utils';
import { ConstantExecutor, ErrorExecutor, EventExecutor, RuntimeApiExecutorV2, StorageQueryExecutorV2, TxExecutorV2, } from '../executor/index.js';
import { ChainHead, ChainSpec, Transaction, TransactionWatch } from '../json-rpc/index.js';
import { newProxyChain } from '../proxychain.js';
import { BaseSubstrateClient, ensurePresence } from './BaseSubstrateClient.js';
/**
 * @name DedotClient
 * @description New promised-based API Client for Polkadot & Substrate based on JSON-RPC V2
 *
 * __Unstable, use with caution.__
 */
export class DedotClient// prettier-end-here
 extends BaseSubstrateClient {
    _chainHead;
    _chainSpec;
    _txBroadcaster;
    #apiAtCache = {};
    /**
     * Use factory methods (`create`, `new`) to create `DedotClient` instances.
     *
     * @param options
     */
    constructor(options) {
        super('v2', options);
    }
    /**
     * Factory method to create a new DedotClient instance
     *
     * @param options
     */
    static async create(options) {
        return new DedotClient(options).connect();
    }
    /**
     * Alias for __DedotClient.create__
     *
     * @param options
     */
    static async new(options) {
        return DedotClient.create(options);
    }
    get chainSpec() {
        return ensurePresence(this._chainSpec);
    }
    get chainHead() {
        return ensurePresence(this._chainHead);
    }
    get txBroadcaster() {
        this.chainHead; // Ensure chain head is initialized
        assert(this._txBroadcaster, 'JSON-RPC method to broadcast transactions is not supported by the server/node.');
        return this._txBroadcaster;
    }
    async #initializeTxBroadcaster(rpcMethods) {
        const tx = new Transaction(this, { rpcMethods });
        if (await tx.supported())
            return tx;
        const txWatch = new TransactionWatch(this, { rpcMethods });
        if (await txWatch.supported())
            return txWatch;
    }
    /**
     * Initialize APIs before usage
     */
    async doInitialize() {
        const rpcMethods = (await this.rpc.rpc_methods()).methods;
        this._chainHead = new ChainHead(this, { rpcMethods });
        this._chainSpec = new ChainSpec(this, { rpcMethods });
        this._txBroadcaster = await this.#initializeTxBroadcaster(rpcMethods);
        // Fetching node information
        let [_, genesisHash] = await Promise.all([
            this.chainHead.follow(),
            this.chainSpec.genesisHash().catch(() => undefined),
        ]);
        this._genesisHash = genesisHash || (await this.#getGenesisHashFallback());
        this._runtimeVersion = await this.chainHead.bestRuntimeVersion();
        let metadata;
        if (await this.shouldPreloadMetadata()) {
            metadata = await this.fetchMetadata();
        }
        await this.setupMetadata(metadata);
        this.subscribeRuntimeUpgrades();
    }
    /**
     * Ref: https://github.com/paritytech/polkadot-sdk/blob/bbd51ce867967f71657b901f1a956ad4f75d352e/substrate/frame/system/src/lib.rs#L909-L913
     * @private
     */
    async #getGenesisHashFallback() {
        const pallet = xxhashAsU8a('System', 128);
        const item = xxhashAsU8a('BlockHash', 128);
        const blockHeightAt0 = twox64Concat(u32.encode(0));
        const key = u8aToHex(concatU8a(pallet, item, blockHeightAt0));
        const storageValue = await this.chainHead.storage([{ type: 'value', key }]);
        const rawGenesisHash = storageValue.at(0)?.value;
        assert(rawGenesisHash, 'Genesis hash not found!');
        // Here we assume that in most case the hash is stored as a H256
        return $H256.tryDecode(rawGenesisHash);
    }
    subscribeRuntimeUpgrades() {
        this.chainHead.on('bestBlock', this.onRuntimeUpgrade);
    }
    onRuntimeUpgrade = async (block) => {
        const runtimeUpgraded = block.runtime && block.runtime.specVersion !== this._runtimeVersion?.specVersion;
        if (!runtimeUpgraded)
            return;
        this.startRuntimeUpgrade();
        this._runtimeVersion = block.runtime;
        const newMetadata = await this.fetchMetadata(undefined, this._runtimeVersion);
        await this.setupMetadata(newMetadata);
        this.emit('runtimeUpgraded', this._runtimeVersion);
        this.doneRuntimeUpgrade();
    };
    async beforeDisconnect() {
        await this.chainHead.unfollow();
    }
    onDisconnected = async () => {
        this.chainHead.unfollow().catch(noop);
    };
    cleanUp() {
        super.cleanUp();
        this._chainHead = undefined;
        this._chainSpec = undefined;
        this._txBroadcaster = undefined;
        this.#apiAtCache = {};
    }
    get query() {
        return newProxyChain({
            executor: new StorageQueryExecutorV2(this, this.chainHead),
        });
    }
    get call() {
        return this.callAt();
    }
    callAt(blockHash) {
        return newProxyChain({
            executor: new RuntimeApiExecutorV2(this, this.chainHead, blockHash),
        });
    }
    get tx() {
        return newProxyChain({ executor: new TxExecutorV2(this) });
    }
    /**
     * Get a new API instance at a specific block hash
     * For now, this only supports pinned block hashes from the chain head
     *
     * @param hash
     */
    async at(hash) {
        if (this.#apiAtCache[hash])
            return this.#apiAtCache[hash];
        const targetBlock = this.chainHead.findBlock(hash);
        assert(targetBlock, 'Block is not pinned!');
        let targetVersion = targetBlock.runtime;
        if (!targetVersion) {
            // fallback to fetching on-chain runtime if we can't find it in the block
            targetVersion = this.toSubstrateRuntimeVersion(await this.callAt(hash).core.version());
        }
        let metadata = this.metadata;
        let registry = this.registry;
        if (targetVersion && targetVersion.specVersion !== this.runtimeVersion.specVersion) {
            metadata = await this.fetchMetadata(hash, targetVersion);
            registry = new PortableRegistry(metadata.latest, this.options.hasher);
        }
        const api = {
            rpcVersion: 'v2',
            atBlockHash: hash,
            options: this.options,
            genesisHash: this.genesisHash,
            runtimeVersion: targetVersion,
            metadata,
            registry,
            rpc: this.rpc,
        };
        api.consts = newProxyChain({ executor: new ConstantExecutor(api) });
        api.events = newProxyChain({ executor: new EventExecutor(api) });
        api.errors = newProxyChain({ executor: new ErrorExecutor(api) });
        api.query = newProxyChain({ executor: new StorageQueryExecutorV2(api, this.chainHead) });
        api.call = newProxyChain({ executor: new RuntimeApiExecutorV2(api, this.chainHead) });
        this.#apiAtCache[hash] = api;
        return api;
    }
}
