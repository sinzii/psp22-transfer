import { PortableRegistry } from '@dedot/codecs';
import { ConstantExecutor, ErrorExecutor, EventExecutor, RuntimeApiExecutor, StorageQueryExecutor, TxExecutor, } from '../executor/index.js';
import { newProxyChain } from '../proxychain.js';
import { BaseSubstrateClient } from './BaseSubstrateClient.js';
const KEEP_ALIVE_INTERVAL = 10_000; // in ms
/**
 * @name LegacyClient
 * @description Promised-based API Client for Polkadot & Substrate
 *
 * Initialize API instance and interact with substrate-based network
 * ```typescript
 * import { Dedot } from 'dedot';
 * import type { PolkadotApi } from '@dedot/chaintypes/polkadot';
 *
 * const run = async () => {
 *   const api = await LegacyClient.new<PolkadotApi>('wss://rpc.polkadot.io');
 *
 *   // Call rpc `state_getMetadata` to fetch raw scale-encoded metadata and decode it.
 *   const metadata = await api.rpc.state.getMetadata();
 *   console.log('Metadata:', metadata);
 *
 *   // Query on-chain storage
 *   const address = '14...';
 *   const balance = await api.query.system.account(address);
 *   console.log('Balance:', balance);
 *
 *
 *   // Subscribe to on-chain storage changes
 *   const unsub = await api.query.system.number((blockNumber) => {
 *     console.log(`Current block number: ${blockNumber}`);
 *   });
 *
 *   // Get pallet constants
 *   const ss58Prefix = api.consts.system.ss58Prefix;
 *   console.log('Polkadot ss58Prefix:', ss58Prefix)
 *
 *   // await unsub();
 *   // await api.disconnect();
 * }
 *
 * run().catch(console.error);
 * ```
 */
export class LegacyClient// prettier-end-here
 extends BaseSubstrateClient {
    #runtimeSubscriptionUnsub;
    #healthTimer;
    #apiAtCache = {};
    /**
     * Use factory methods (`create`, `new`) to create `Dedot` instances.
     *
     * @param options
     */
    constructor(options) {
        super('legacy', options);
    }
    /**
     * Factory method to create a new Dedot instance
     *
     * @param options
     */
    static async create(options) {
        return new LegacyClient(options).connect();
    }
    /**
     * Alias for __LegacyClient.create__
     *
     * @param options
     */
    static async new(options) {
        return LegacyClient.create(options);
    }
    onDisconnected = async () => {
        await this.#unsubscribeUpdates();
    };
    async beforeDisconnect() {
        await this.#unsubscribeUpdates();
    }
    /**
     * Initialize APIs before usage
     */
    async doInitialize() {
        let [genesisHash, runtimeVersion, metadata] = await Promise.all([
            this.rpc.chain_getBlockHash(0),
            this.#getRuntimeVersion(),
            (await this.shouldPreloadMetadata()) ? this.fetchMetadata() : Promise.resolve(undefined),
        ]);
        this._genesisHash = genesisHash;
        this._runtimeVersion = runtimeVersion;
        await this.setupMetadata(metadata);
        this.#subscribeUpdates();
    }
    cleanUp() {
        super.cleanUp();
        this.#apiAtCache = {};
        this.#healthTimer = undefined;
        this.#runtimeSubscriptionUnsub = undefined;
    }
    #subscribeRuntimeUpgrades() {
        if (this.#runtimeSubscriptionUnsub)
            return;
        this.rpc
            .state_subscribeRuntimeVersion(async (runtimeVersion) => {
            if (runtimeVersion.specVersion !== this.runtimeVersion?.specVersion) {
                this.startRuntimeUpgrade();
                this._runtimeVersion = this.toSubstrateRuntimeVersion(runtimeVersion);
                const newMetadata = await this.fetchMetadata(undefined, this._runtimeVersion);
                await this.setupMetadata(newMetadata);
                this.emit('runtimeUpgraded', this._runtimeVersion);
                this.doneRuntimeUpgrade();
            }
        })
            .then((unsub) => {
            this.#runtimeSubscriptionUnsub = unsub;
        });
    }
    async #getRuntimeVersion(at) {
        return this.toSubstrateRuntimeVersion(await this.rpc.state_getRuntimeVersion(at));
    }
    #subscribeHealth() {
        this.#unsubscribeHealth();
        this.#healthTimer = setInterval(() => {
            this.rpc.system_health().catch(console.error);
        }, KEEP_ALIVE_INTERVAL);
    }
    #unsubscribeHealth() {
        if (!this.#healthTimer) {
            return;
        }
        clearInterval(this.#healthTimer);
        this.#healthTimer = undefined;
    }
    async #unsubscribeRuntimeUpdates() {
        if (!this.#runtimeSubscriptionUnsub) {
            return;
        }
        await this.#runtimeSubscriptionUnsub();
        this.#runtimeSubscriptionUnsub = undefined;
    }
    #subscribeUpdates() {
        this.#subscribeRuntimeUpgrades();
        this.#subscribeHealth();
    }
    async #unsubscribeUpdates() {
        await this.#unsubscribeRuntimeUpdates();
        this.#unsubscribeHealth();
    }
    /// --- Public APIs ---
    /**
     * @description Entry-point for inspecting constants (parameter types) for all pallets (modules).
     *
     * ```typescript
     * const ss58Prefix = api.consts.system.ss58Prefix;
     * console.log('ss58Prefix:', ss58Prefix)
     * ```
     */
    get consts() {
        return newProxyChain({ executor: new ConstantExecutor(this) });
    }
    /**
     * @description Entry-point for executing query to on-chain storage.
     *
     * ```typescript
     * const balance = await api.query.system.account(<address>);
     * console.log('Balance:', balance);
     * ```
     */
    get query() {
        return newProxyChain({ executor: new StorageQueryExecutor(this) });
    }
    /**
     * @description Entry-point for inspecting errors from metadata
     */
    get errors() {
        return newProxyChain({ executor: new ErrorExecutor(this) });
    }
    /**
     * @description Entry-point for inspecting events from metadata
     */
    get events() {
        return newProxyChain({ executor: new EventExecutor(this) });
    }
    /**
     * @description Entry-point for executing runtime api
     *
     * ```typescript
     * // Get account nonce
     * const nonce = await api.call.accountNonceApi.accountNonce(<address>);
     *
     * // Query transaction payment info
     * const tx = api.tx.balances.transferKeepAlive(<address>, 2_000_000_000_000n);
     * const queryInfo = await api.call.transactionPaymentApi.queryInfo(tx.toU8a(), tx.length);
     * ```
     */
    get call() {
        return this.callAt();
    }
    // For internal use with caution
    callAt(hash) {
        return newProxyChain({ executor: new RuntimeApiExecutor(this, hash) });
    }
    /**
     * @description Entry-point for executing on-chain transactions
     *
     * ```typescript
     * // Make a transfer balance transaction
     * api.tx.balances.transferKeepAlive(<address>, <amount>)
     *    .signAndSend(<keyPair|address>, { signer }, ({ status }) => {
     *      console.log('Transaction status', status.type);
     *    });
     * ```
     */
    get tx() {
        return newProxyChain({ executor: new TxExecutor(this) });
    }
    /**
     * Create a new API instance at a specific block hash
     * This is useful when we want to inspect the state of the chain at a specific block hash
     *
     * @param hash
     */
    async at(hash) {
        if (this.#apiAtCache[hash])
            return this.#apiAtCache[hash];
        const targetVersion = await this.#getRuntimeVersion(hash);
        let metadata = this.metadata;
        let registry = this.registry;
        if (targetVersion.specVersion !== this.runtimeVersion.specVersion) {
            metadata = await this.fetchMetadata(hash, targetVersion);
            registry = new PortableRegistry(metadata.latest, this.options.hasher);
        }
        const api = {
            rpcVersion: 'legacy',
            atBlockHash: hash,
            options: this.options,
            genesisHash: this.genesisHash,
            runtimeVersion: targetVersion,
            metadata,
            registry,
            rpc: this.rpc,
        };
        api.consts = newProxyChain({ executor: new ConstantExecutor(api) });
        api.query = newProxyChain({ executor: new StorageQueryExecutor(api) });
        api.call = newProxyChain({ executor: new RuntimeApiExecutor(api) });
        api.events = newProxyChain({ executor: new EventExecutor(api) });
        api.errors = newProxyChain({ executor: new ErrorExecutor(api) });
        this.#apiAtCache[hash] = api;
        return api;
    }
}
