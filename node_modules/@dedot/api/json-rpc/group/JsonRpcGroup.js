import { EventEmitter } from '@dedot/utils';
/**
 * @name JsonRpcGroup
 * A group of json-rpc methods with a common prefix.
 *
 * JSON-RPC V2: https://paritytech.github.io/json-rpc-interface-spec/grouping-functions-and-node-capabilities.html#grouping-functions-and-node-capabilities
 */
export class JsonRpcGroup extends EventEmitter {
    client;
    options;
    #detectedVersion;
    constructor(client, options) {
        super();
        this.client = client;
        this.options = options;
    }
    /**
     * Check if the group is supported by the connected JSON-RPC server.
     */
    async supported() {
        try {
            const detectedVersion = await this.#detectVersion();
            const { supportedVersions } = this.options;
            // if there aren't any specific supported versions, then any detected version is supported
            if (!supportedVersions || supportedVersions.length === 0)
                return true;
            return supportedVersions.includes(detectedVersion);
        }
        catch { }
        return false;
    }
    /**
     * Send a json-rpc request, note the method should not contain the prefix and version parts.
     *
     * @example
     * ```typescript
     * const client = await JsonRpcClient.new('wss://rpc.polkadot.io');
     * const achieve = new JsonRpcGroup(client, { prefix: 'archive', supportedVersions: ['unstable'] });
     *
     * const finalizedHeight = await achieve.send<number>('finalizedHeight'); // sending archive_unstable_finalizedHeight
     * console.log(finalizedHeight);
     * ```
     *
     * @param method
     * @param params
     */
    async send(method, ...params) {
        const rpcMethod = `${this.prefix}_${await this.version()}_${method}`;
        return this.client.rpc[rpcMethod](...params);
    }
    /**
     * The prefix of the group
     */
    get prefix() {
        return this.options.prefix;
    }
    /**
     * Detect & return the version of the group.
     * This will be used to construct the json-rpc method name.
     */
    async version() {
        const { fixedVersion, supportedVersions } = this.options;
        if (fixedVersion)
            return fixedVersion;
        const detectedVersion = await this.#detectVersion();
        if (supportedVersions && supportedVersions.length > 0 && !supportedVersions.includes(detectedVersion)) {
            throw new Error(`Detected version ${detectedVersion} is not supported`);
        }
        return detectedVersion;
    }
    async #detectVersion() {
        if (!this.#detectedVersion) {
            this.#detectedVersion = await this.#doDetectVersion();
        }
        return this.#detectedVersion;
    }
    async #doDetectVersion() {
        const rpcMethods = this.options.rpcMethods || (await this.client.rpc.rpc_methods()).methods;
        const prefixedMethods = rpcMethods.filter((method) => method.startsWith(`${this.prefix}_`));
        if (prefixedMethods.length === 0) {
            throw new Error(`No methods found with prefix ${this.prefix}`);
        }
        return prefixedMethods[0].split('_')[1];
    }
}
