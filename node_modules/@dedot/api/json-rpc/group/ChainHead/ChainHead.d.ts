import { BlockHash, Option } from '@dedot/codecs';
import type { ChainHeadRuntimeVersion, OperationId, StorageQuery, StorageResult } from '@dedot/types/json-rpc';
import { Deferred, HexString } from '@dedot/utils';
import type { IJsonRpcClient } from '../../../types.js';
import { JsonRpcGroup, type JsonRpcGroupOptions } from '../JsonRpcGroup.js';
export type OperationHandler<T = any> = {
    operationId: OperationId;
    defer: Deferred<T>;
    storageResults?: Array<StorageResult>;
    hash: BlockHash;
};
export type PinnedBlock = {
    hash: BlockHash;
    number: number;
    parent: BlockHash;
    runtime?: ChainHeadRuntimeVersion;
};
export type ChainHeadEvent = 'newBlock' | 'bestBlock' | 'finalizedBlock' | 'bestChainChanged';
export declare const MIN_FINALIZED_QUEUE_SIZE = 10;
export declare class ChainHead extends JsonRpcGroup<ChainHeadEvent> {
    #private;
    constructor(client: IJsonRpcClient, options?: Partial<JsonRpcGroupOptions>);
    runtimeVersion(): Promise<ChainHeadRuntimeVersion>;
    bestRuntimeVersion(): Promise<ChainHeadRuntimeVersion>;
    finalizedHash(): Promise<BlockHash>;
    bestHash(): Promise<BlockHash>;
    bestBlock(): Promise<PinnedBlock>;
    finalizedBlock(): Promise<PinnedBlock>;
    findBlock(hash: BlockHash): PinnedBlock | undefined;
    isPinned(hash: BlockHash): boolean;
    /**
     * chainHead_unfollow
     */
    unfollow(): Promise<void>;
    /**
     * chainHead_follow
     */
    follow(): Promise<void>;
    /**
     * chainHead_body
     */
    body(at?: BlockHash): Promise<Array<HexString>>;
    /**
     * chainHead_call
     */
    call(func: string, params?: HexString, at?: BlockHash): Promise<HexString>;
    /**
     * chainHead_header
     */
    header(at?: BlockHash): Promise<Option<HexString>>;
    /**
     * chainHead_storage
     */
    storage(items: Array<StorageQuery>, childTrie?: string | null, at?: BlockHash): Promise<Array<StorageResult>>;
    /**
     * chainHead_stopOperation
     * @protected
     */
    protected stopOperation(operationId: OperationId): Promise<void>;
    /**
     * chainHead_continue
     * @protected
     */
    protected continue(operationId: OperationId): Promise<void>;
    /**
     * chainHead_unpin
     * @protected
     */
    protected unpin(hashes: BlockHash | BlockHash[]): Promise<void>;
}
