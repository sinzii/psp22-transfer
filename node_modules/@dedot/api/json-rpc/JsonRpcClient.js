import { assert, EventEmitter, isFunction, isString } from '@dedot/utils';
import { scaledResponses } from './scaledResponses.js';
import { subscriptionsInfo } from './subscriptionsInfo.js';
export const isJsonRpcProvider = (provider) => {
    return (provider &&
        isString(provider.status) &&
        isFunction(provider.send) &&
        isFunction(provider.subscribe) &&
        isFunction(provider.connect) &&
        isFunction(provider.disconnect));
};
export class JsonRpcClient extends EventEmitter {
    #options;
    #provider;
    constructor(options) {
        super();
        if (isJsonRpcProvider(options)) {
            this.#options = { provider: options };
            this.#provider = options;
        }
        else {
            this.#options = options;
            this.#provider = options.provider;
        }
        assert(this.#provider, 'A JsonRpcProvider is required');
    }
    /**
     * Factory method to create a new JsonRpcClient instance
     *
     * @param options
     */
    static async create(options) {
        return new JsonRpcClient(options).connect();
    }
    /**
     * Alias for __JsonRpcClient.create__
     *
     * @param options
     */
    static async new(options) {
        return JsonRpcClient.create(options);
    }
    get options() {
        return this.#options;
    }
    /**
     * @description Check connection status of the api instance
     */
    get status() {
        return this.provider.status;
    }
    /**
     * @description Get the JSON-RPC provider instance
     */
    get provider() {
        return this.#provider;
    }
    connect() {
        return this.#doConnect();
    }
    async #doConnect() {
        this.provider.on('connected', this.#onConnected);
        this.provider.on('disconnected', this.#onDisconnected);
        this.provider.on('reconnecting', this.#onReconnecting);
        this.provider.on('error', this.#onError);
        return new Promise((resolve, reject) => {
            // @ts-ignore
            this.once('connected', () => {
                resolve(this);
            });
            if (this.status === 'connected') {
                this.#onConnected().catch(reject);
            }
            else {
                this.provider.connect().catch(reject);
            }
        });
    }
    #onConnected = async () => {
        // @ts-ignore
        this.emit('connected');
    };
    #onDisconnected = async () => {
        // @ts-ignore
        this.emit('disconnected');
    };
    #onReconnecting = async () => {
        // @ts-ignore
        this.emit('reconnecting');
    };
    #onError = async (e) => {
        // @ts-ignore
        this.emit('error', e);
    };
    async disconnect() {
        await this.#provider.disconnect();
        this.clearEvents();
    }
    /**
     * @description Entry-point for executing JSON-RPCs to blockchain node.
     *
     * ```typescript
     * const client = new JsonRpcClient('wss://rpc.polkadot.io');
     * await client.connect();
     *
     * // Subscribe to new heads
     * client.rpc.chain_subscribeNewHeads((header) => {
     *   console.log(header);
     * });
     *
     * // Execute arbitrary rpc method: `module_rpc_name`
     * const result = await client.rpc.module_rpc_name();
     * ```
     */
    get rpc() {
        return new Proxy(this, {
            get(target, property, receiver) {
                const rpcMethod = property.toString();
                return target.#doExecute(rpcMethod);
            },
        });
    }
    #doExecute(rpcName) {
        const subscriptionInfo = this.options.subscriptions?.[rpcName] || subscriptionsInfo[rpcName];
        const isSubscription = !!subscriptionInfo;
        const fnRpc = async (...args) => {
            const result = await this.provider.send(rpcName, args);
            return this.#tryDecode(rpcName, result);
        };
        const fnSubRpc = async (...args) => {
            const inArgs = args.slice();
            const callback = inArgs.pop();
            assert(isFunction(callback), 'A callback is required for subscription');
            const onNewMessage = (error, result, subscription) => {
                if (error) {
                    console.error(error);
                    return;
                }
                callback(this.#tryDecode(rpcName, result), subscription);
            };
            const [subname, unsubscribe] = subscriptionInfo;
            const subscription = await this.provider.subscribe({ subname, subscribe: rpcName, params: inArgs, unsubscribe }, onNewMessage);
            return async () => {
                await subscription.unsubscribe();
            };
        };
        return isSubscription ? fnSubRpc : fnRpc;
    }
    #tryDecode(rpcName, raw) {
        if (raw === null) {
            // We use `undefined` to represent Option::None in the client
            return undefined;
        }
        const $maybeCodec = this.options.scaledResponses?.[rpcName] || scaledResponses[rpcName];
        if ($maybeCodec) {
            return $maybeCodec.tryDecode(raw);
        }
        return raw;
    }
}
