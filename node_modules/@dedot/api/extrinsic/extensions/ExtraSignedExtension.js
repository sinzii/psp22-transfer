import * as $ from '@dedot/shape';
import { assert, ensurePresence, u8aToHex } from '@dedot/utils';
import { SignedExtension } from './SignedExtension.js';
import { knownSignedExtensions } from './known/index.js';
export class ExtraSignedExtension extends SignedExtension {
    #signedExtensions;
    async init() {
        this.#signedExtensions = this.#getSignedExtensions();
        await Promise.all(this.#signedExtensions.map((se) => se.init()));
        this.data = this.#signedExtensions.map((se) => se.data);
        this.additionalSigned = this.#signedExtensions.map((se) => se.additionalSigned);
    }
    get identifier() {
        return 'ExtraSignedExtension';
    }
    get $Data() {
        const { extraTypeId } = this.registry.metadata.extrinsic;
        return ensurePresence(this.registry.findCodec(extraTypeId));
    }
    get $AdditionalSigned() {
        const $AdditionalSignedCodecs = this.#signedExtensionDefs.map((se) => this.registry.findCodec(se.additionalSigned));
        return $.Tuple(...$AdditionalSignedCodecs);
    }
    get $Payload() {
        const { callTypeId } = this.registry.metadata.extrinsic;
        const $Call = this.registry.findCodec(callTypeId);
        return $.Tuple($Call, this.$Data, this.$AdditionalSigned);
    }
    get #signedExtensionDefs() {
        return this.registry.metadata.extrinsic.signedExtensions;
    }
    #getSignedExtensions() {
        return this.#signedExtensionDefs.map((extDef) => {
            const { signedExtensions: userSignedExtensions = {} } = this.client.options;
            const Extension = userSignedExtensions[extDef.ident] ||
                knownSignedExtensions[extDef.ident];
            assert(Extension, `SignedExtension for ${extDef.ident} not found`);
            return new Extension(this.client, {
                ...ensurePresence(this.options),
                def: extDef,
            });
        });
    }
    toPayload(call = '0x') {
        const signedExtensions = this.#signedExtensions.map((se) => se.identifier);
        const { version } = this.registry.metadata.extrinsic;
        return Object.assign({ address: this.options.signerAddress, signedExtensions, version, method: call }, ...this.#signedExtensions.map((se) => se.toPayload()));
    }
    toRawPayload(call = '0x') {
        const payload = this.toPayload(call);
        const $ToSignPayload = $.Tuple($.RawHex, this.$Data, this.$AdditionalSigned);
        const toSignPayload = [call, this.data, this.additionalSigned];
        const rawPayload = $ToSignPayload.tryEncode(toSignPayload);
        return {
            address: payload.address,
            data: u8aToHex(rawPayload),
            type: 'payload',
        };
    }
}
