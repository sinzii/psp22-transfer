"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParachainHost = void 0;
const codecs_1 = require("@dedot/codecs");
const $ = __importStar(require("@dedot/shape"));
const V5_V10_SHARED = {
    validators: {
        docs: 'Get the current validators.',
        params: [],
        type: 'Array<ValidatorId>',
        codec: $.Array(codecs_1.$ValidatorId),
    },
    validatorGroups: {
        docs: [
            'Returns the validator groups and rotation info localized based on the hypothetical child',
            ' of a block whose state  this is invoked on. Note that `now` in the `GroupRotationInfo`',
            'should be the successor of the number of the block.',
        ],
        params: [],
        type: '[Array<Array<ParaValidatorIndex>>, GroupRotationInfo]',
        codec: $.Tuple($.Array($.Array(codecs_1.$ParaValidatorIndex)), codecs_1.$GroupRotationInfo),
    },
    availabilityCores: {
        docs: [
            'Yields information on all availability cores as relevant to the child block.',
            'Cores are either free or occupied. Free cores can have paras assigned to them.',
        ],
        params: [],
        type: 'Array<CoreState>',
        codec: $.Array(codecs_1.$CoreState),
    },
    persistedValidationData: {
        docs: [
            'Yields the persisted validation data for the given `ParaId` along with an assumption that',
            'should be used if the para currently occupies a core.',
            '\n',
            'Returns `None` if either the para is not registered or the assumption is `Freed`',
            'and the para already occupies a core.',
        ],
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
            {
                name: 'assumption',
                type: 'OccupiedCoreAssumption',
                codec: codecs_1.$OccupiedCoreAssumption,
            },
        ],
        type: 'Option<PersistedValidationData>',
        codec: $.Option(codecs_1.$PersistedValidationData),
    },
    assumedValidationData: {
        docs: [
            'Returns the persisted validation data for the given `ParaId` along with the corresponding',
            'validation code hash. Instead of accepting assumption about the para, matches the validation',
            "data hash against an expected one and yields `None` if they're not equal.",
        ],
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
            {
                name: 'expectedPersistedValidationDataHash',
                type: 'Hash',
                codec: codecs_1.$Hash,
            },
        ],
        type: 'Option<[PersistedValidationData, ValidationCodeHash]>',
        codec: $.Option($.Tuple(codecs_1.$PersistedValidationData, codecs_1.$ValidationCodeHash)),
    },
    checkValidationOutputs: {
        docs: 'Checks if the given validation outputs pass the acceptance criteria.',
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
            {
                name: 'outputs',
                type: 'CandidateCommitments',
                codec: codecs_1.$CandidateCommitments,
            },
        ],
        type: 'bool',
        codec: $.bool,
    },
    sessionIndexForChild: {
        docs: [
            'Returns the session index expected at a child of the block.',
            '\n',
            'This can be used to instantiate a `SigningContext`.',
        ],
        params: [],
        type: 'SessionIndex',
        codec: codecs_1.$SessionIndex,
    },
    validationCode: {
        docs: [
            'Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.',
            '\n',
            'Returns `None` if either the para is not registered or the assumption is `Freed`',
            'and the para already occupies a core.',
        ],
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
            {
                name: 'assumption',
                type: 'OccupiedCoreAssumption',
                codec: codecs_1.$OccupiedCoreAssumption,
            },
        ],
        type: 'ValidationCode',
        codec: codecs_1.$ValidationCode,
    },
    candidatePendingAvailability: {
        docs: [
            'Get the receipt of a candidate pending availability. This returns `Some` for any paras',
            'assigned to occupied cores in `availability_cores` and `None` otherwise.',
        ],
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
        ],
        type: 'Option<CommittedCandidateReceipt>',
        codec: $.Option(codecs_1.$CommittedCandidateReceipt),
    },
    candidateEvents: {
        docs: 'Get a vector of events concerning candidates that occurred within a block.',
        params: [],
        type: 'Array<CandidateEvent>',
        codec: $.Array(codecs_1.$CandidateEvent),
    },
    dmqContents: {
        docs: 'Get all the pending inbound messages in the downward message queue for a para.',
        params: [
            {
                name: 'recipient',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
        ],
        type: 'Array<InboundDownwardMessage>',
        codec: $.Array(codecs_1.$InboundDownwardMessage),
    },
    inboundHrmpChannelsContents: {
        docs: [
            'Get the contents of all channels addressed to the given recipient. Channels that have no',
            'messages in them are also included.',
        ],
        params: [
            {
                name: 'recipient',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
        ],
        //! Notice here
        type: 'Array<InboundHrmpMessage>',
        codec: $.Array(codecs_1.$InboundHrmpMessage),
    },
    validationCodeByHash: {
        docs: 'Get the validation code from its hash.',
        params: [
            {
                name: 'hash',
                type: 'ValidationCodeHash',
                codec: codecs_1.$ValidationCodeHash,
            },
        ],
        type: 'Option<ValidationCode>',
        codec: $.Option(codecs_1.$ValidationCode),
    },
    onChainVotes: {
        docs: 'Scrape dispute relevant from on-chain, backing votes and resolved disputes.',
        params: [],
        type: 'Option<ScrapedOnChainVotes>',
        codec: $.Option(codecs_1.$ScrapedOnChainVotes),
    },
    sessionInfo: {
        docs: 'Get the session info for the given session, if stored.',
        params: [
            {
                name: 'index',
                type: 'SessionIndex',
                codec: codecs_1.$SessionIndex,
            },
        ],
        type: 'Option<SessionInfo>',
        codec: $.Option(codecs_1.$SessionInfo),
    },
    submitPvfCheckStatement: {
        docs: 'Submits a PVF pre-checking statement into the transaction pool.',
        params: [
            {
                name: 'stmt',
                type: 'PvfCheckStatement',
                codec: codecs_1.$PvfCheckStatement,
            },
            {
                name: 'signature',
                type: 'ValidatorSignature',
                codec: codecs_1.$ValidatorSignature,
            },
        ],
        type: '[]',
        codec: $.Tuple(),
    },
    pvfsRequirePrecheck: {
        docs: 'Returns code hashes of PVFs that require pre-checking by validators in the active set.',
        params: [],
        type: 'Array<ValidationCodeHash>',
        codec: $.Array(codecs_1.$ValidationCodeHash),
    },
    validationCodeHash: {
        docs: 'Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.',
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
            {
                name: 'assumption',
                type: 'OccupiedCoreAssumption',
                codec: codecs_1.$OccupiedCoreAssumption,
            },
        ],
        type: 'Option<ValidationCodeHash>',
        codec: $.Option(codecs_1.$ValidationCodeHash),
    },
    disputes: {
        docs: 'Returns all onchain disputes.',
        params: [],
        type: 'Array<[SessionIndex, CandidateHash, DisputeState]>',
        codec: $.Array($.Tuple(codecs_1.$SessionIndex, codecs_1.$CandidateHash, codecs_1.$DisputeState)),
    },
    sessionExecutorParams: {
        docs: 'Returns execution parameters for the session.',
        params: [
            {
                name: 'sessionIndex',
                type: 'SessionIndex',
                codec: codecs_1.$SessionIndex,
            },
        ],
        type: 'Option<ExecutorParams>',
        codec: $.Option(codecs_1.$ExecutorParams),
    },
    unappliedSlashes: {
        docs: 'Returns a list of validators that lost a past session dispute and need to be slashed',
        params: [],
        type: 'Array<[SessionIndex, CandidateHash, PendingSlashes]>',
        codec: $.Array($.Tuple(codecs_1.$SessionIndex, codecs_1.$CandidateHash, codecs_1.$PendingSlashes)),
    },
    keyOwnershipProof: {
        docs: 'Returns a merkle proof of a validator session key',
        params: [
            {
                name: 'validatorId',
                type: 'ValidatorId',
                codec: codecs_1.$ValidatorId,
            },
        ],
        type: 'Option<OpaqueKeyOwnershipProof>',
        codec: $.Option(codecs_1.$OpaqueKeyOwnershipProof),
    },
    submitReportDisputeLost: {
        docs: 'Submit an unsigned extrinsic to slash validators who lost a dispute about a candidate of a past session',
        params: [
            {
                name: 'disputeProof',
                type: 'DisputeProof',
                codec: codecs_1.$DisputeProof,
            },
            {
                name: 'keyOwnershipProof',
                type: 'OpaqueKeyOwnershipProof',
                codec: codecs_1.$OpaqueKeyOwnershipProof,
            },
        ],
        type: 'Option<[]>',
        codec: $.Option($.Tuple()),
    },
};
const V6_V10_SHARED = {
    minimumBackingVotes: {
        docs: [
            'Get the minimum number of backing votes for a parachain candidate.',
            'This is a staging method! Do not use on production runtimes!',
        ],
        params: [],
        type: 'u32',
        codec: $.u32,
    },
};
const V7_V10_SHARED = {
    paraBackingState: {
        docs: 'Returns the state of parachain backing for a given para.',
        params: [
            {
                name: 'paraId',
                type: 'ParaId',
                codec: codecs_1.$ParaId,
            },
        ],
        type: 'Option<BackingState>',
        codec: $.Option(codecs_1.$BackingState),
    },
    asyncBackingParams: {
        docs: "Returns candidate's acceptance limitations for asynchronous backing for a relay parent.",
        params: [],
        type: 'AsyncBackingParams',
        codec: codecs_1.$AsyncBackingParams,
    },
};
const V8_V10_SHARED = {
    disabledValidators: {
        docs: 'Returns a list of all disabled validators at the given block.',
        params: [],
        type: 'ParaValidatorIndex',
        codec: codecs_1.$ParaValidatorIndex,
    },
};
const V9_V10_SHARED = {
    nodeFeatures: {
        docs: ['Get node features.', 'This is a staging method! Do not use on production runtimes!'],
        params: [],
        type: 'NodeFeatures',
        codec: codecs_1.$NodeFeatures,
    },
};
/**
 * Ref https://github.com/paritytech/polkadot-sdk/blob/a84dd0dba58d51503b8942360aa4fb30a5a96af5/polkadot/primitives/src/runtime_api.rs#L129-L134
 */
exports.ParachainHost = [
    { methods: { ...V5_V10_SHARED }, version: 5 },
    { methods: { ...V6_V10_SHARED, ...V5_V10_SHARED }, version: 6 },
    { methods: { ...V7_V10_SHARED, ...V6_V10_SHARED, ...V5_V10_SHARED }, version: 7 },
    { methods: { ...V8_V10_SHARED, ...V7_V10_SHARED, ...V6_V10_SHARED, ...V5_V10_SHARED }, version: 8 },
    {
        methods: { ...V9_V10_SHARED, ...V8_V10_SHARED, ...V7_V10_SHARED, ...V6_V10_SHARED, ...V5_V10_SHARED },
        version: 9,
    },
    {
        methods: {
            approvalVotingParams: {
                docs: 'Approval voting configuration parameters',
                params: [],
                type: 'ApprovalVotingParams',
                codec: codecs_1.$ApprovalVotingParams,
            },
            ...V5_V10_SHARED,
            ...V6_V10_SHARED,
            ...V7_V10_SHARED,
            ...V8_V10_SHARED,
            ...V9_V10_SHARED,
        },
        version: 10,
    },
];
