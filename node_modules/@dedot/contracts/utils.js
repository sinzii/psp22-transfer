import { stringCamelCase } from '@dedot/utils';
export const extractContractTypes = (contractMetadata) => {
    const { types } = contractMetadata;
    return types.map(({ type, id }) => ({
        id,
        typeDef: normalizeContractTypeDef(type.def),
        params: [],
        path: type?.path || [],
        docs: [],
    }));
};
export const normalizeContractTypeDef = (def) => {
    let type;
    let value;
    if (def.variant) {
        type = 'Enum';
        value = {
            members: def.variant.variants?.map((variant) => ({
                fields: variant.fields?.map((fields) => ({ typeId: fields.type, typeName: fields.typeName })) || [],
                index: variant.index,
                name: variant.name,
            })) || [],
        };
    }
    else if (def.tuple) {
        type = 'Tuple';
        value = {
            fields: def.tuple,
        };
    }
    else if (def.sequence) {
        type = 'Sequence';
        value = {
            typeParam: def.sequence.type,
        };
    }
    else if (def.composite) {
        type = 'Struct';
        value = {
            fields: def.composite.fields?.map((one) => ({
                typeId: one.type,
                name: one.name,
                typeName: one.typeName,
            })) || [],
        };
    }
    else if (def.primitive) {
        type = 'Primitive';
        value = {
            kind: def.primitive,
        };
    }
    else if (def.array) {
        type = 'SizedVec';
        value = {
            len: def.array.len,
            typeParam: def.array.type,
        };
    }
    else {
        throw Error(`Invalid contract type def: ${JSON.stringify(def)}`);
    }
    return { type, value };
};
const UNSUPPORTED_VERSIONS = ['V3', 'V2', 'V1'];
const SUPPORTED_VERSIONS = [5, '4'];
export const parseRawMetadata = (rawMetadata) => {
    const metadata = JSON.parse(rawMetadata);
    // This is for V1, V2, V3
    const unsupportedVersion = UNSUPPORTED_VERSIONS.find((o) => metadata[o]);
    if (unsupportedVersion) {
        throw new Error(`Unsupported metadata version: ${unsupportedVersion}`);
    }
    // This is for V4, V5
    if (!SUPPORTED_VERSIONS.includes(metadata.version)) {
        throw new Error(`Unsupported metadata version: ${metadata.version}`);
    }
    return metadata;
};
export function newProxyChain(carrier) {
    return new Proxy(carrier, {
        get(target, property) {
            return target.doExecute(property.toString());
        },
    });
}
export function ensureSupportContractsPallet(client) {
    try {
        !!client.call.contractsApi.call.meta && !!client.tx.contracts.call.meta;
    }
    catch {
        throw new Error('Contracts pallet is not available');
    }
}
export function normalizeLabel(label) {
    if (!label)
        return '';
    return stringCamelCase(label.replaceAll('::', '_'));
}
// https://github.com/paritytech/polkadot-sdk/blob/d2fd53645654d3b8e12cbf735b67b93078d70113/substrate/frame/contracts/uapi/src/flags.rs#L23-L26
const REVERT_FLAG = 1;
export function toReturnFlags(bits) {
    return {
        bits,
        revert: bits === REVERT_FLAG,
    };
}
