"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toReturnFlags = exports.normalizeLabel = exports.ensureSupportContractsPallet = exports.newProxyChain = exports.parseRawMetadata = exports.normalizeContractTypeDef = exports.extractContractTypes = void 0;
const utils_1 = require("@dedot/utils");
const extractContractTypes = (contractMetadata) => {
    const { types } = contractMetadata;
    return types.map(({ type, id }) => ({
        id,
        typeDef: (0, exports.normalizeContractTypeDef)(type.def),
        params: [],
        path: type?.path || [],
        docs: [],
    }));
};
exports.extractContractTypes = extractContractTypes;
const normalizeContractTypeDef = (def) => {
    let type;
    let value;
    if (def.variant) {
        type = 'Enum';
        value = {
            members: def.variant.variants?.map((variant) => ({
                fields: variant.fields?.map((fields) => ({ typeId: fields.type, typeName: fields.typeName })) || [],
                index: variant.index,
                name: variant.name,
            })) || [],
        };
    }
    else if (def.tuple) {
        type = 'Tuple';
        value = {
            fields: def.tuple,
        };
    }
    else if (def.sequence) {
        type = 'Sequence';
        value = {
            typeParam: def.sequence.type,
        };
    }
    else if (def.composite) {
        type = 'Struct';
        value = {
            fields: def.composite.fields?.map((one) => ({
                typeId: one.type,
                name: one.name,
                typeName: one.typeName,
            })) || [],
        };
    }
    else if (def.primitive) {
        type = 'Primitive';
        value = {
            kind: def.primitive,
        };
    }
    else if (def.array) {
        type = 'SizedVec';
        value = {
            len: def.array.len,
            typeParam: def.array.type,
        };
    }
    else {
        throw Error(`Invalid contract type def: ${JSON.stringify(def)}`);
    }
    return { type, value };
};
exports.normalizeContractTypeDef = normalizeContractTypeDef;
const UNSUPPORTED_VERSIONS = ['V3', 'V2', 'V1'];
const SUPPORTED_VERSIONS = [5, '4'];
const parseRawMetadata = (rawMetadata) => {
    const metadata = JSON.parse(rawMetadata);
    // This is for V1, V2, V3
    const unsupportedVersion = UNSUPPORTED_VERSIONS.find((o) => metadata[o]);
    if (unsupportedVersion) {
        throw new Error(`Unsupported metadata version: ${unsupportedVersion}`);
    }
    // This is for V4, V5
    if (!SUPPORTED_VERSIONS.includes(metadata.version)) {
        throw new Error(`Unsupported metadata version: ${metadata.version}`);
    }
    return metadata;
};
exports.parseRawMetadata = parseRawMetadata;
function newProxyChain(carrier) {
    return new Proxy(carrier, {
        get(target, property) {
            return target.doExecute(property.toString());
        },
    });
}
exports.newProxyChain = newProxyChain;
function ensureSupportContractsPallet(client) {
    try {
        !!client.call.contractsApi.call.meta && !!client.tx.contracts.call.meta;
    }
    catch {
        throw new Error('Contracts pallet is not available');
    }
}
exports.ensureSupportContractsPallet = ensureSupportContractsPallet;
function normalizeLabel(label) {
    if (!label)
        return '';
    return (0, utils_1.stringCamelCase)(label.replaceAll('::', '_'));
}
exports.normalizeLabel = normalizeLabel;
// https://github.com/paritytech/polkadot-sdk/blob/d2fd53645654d3b8e12cbf735b67b93078d70113/substrate/frame/contracts/uapi/src/flags.rs#L23-L26
const REVERT_FLAG = 1;
function toReturnFlags(bits) {
    return {
        bits,
        revert: bits === REVERT_FLAG,
    };
}
exports.toReturnFlags = toReturnFlags;
