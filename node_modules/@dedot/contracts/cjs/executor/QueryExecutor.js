"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryExecutor = void 0;
const utils_1 = require("@dedot/utils");
const errors_js_1 = require("../errors.js");
const utils_js_1 = require("../utils.js");
const index_js_1 = require("./abstract/index.js");
class QueryExecutor extends index_js_1.ContractExecutor {
    doExecute(message) {
        const meta = this.findMessage(message);
        (0, utils_1.assert)(meta, `Query message not found: ${message}`);
        const callFn = async (...params) => {
            const { args } = meta;
            (0, utils_1.assertFalse)(params.length < args.length, `Expected at least ${args.length} arguments, got ${params.length}`);
            (0, utils_1.assertFalse)(params.length > args.length + 1, `Expected at most ${args.length + 1} arguments, got ${params.length}`);
            const callOptions = (params[args.length] || {});
            const { caller = this.options.defaultCaller, value = 0n, gasLimit, storageDepositLimit } = callOptions;
            (0, utils_1.assert)(caller, 'Expected a valid caller address in ContractCallOptions');
            const formattedInputs = args.map((arg, index) => this.tryEncode(arg, params[index]));
            const bytes = (0, utils_1.u8aToHex)((0, utils_1.concatU8a)((0, utils_1.hexToU8a)(meta.selector), ...formattedInputs));
            const raw = await this.client.call.contractsApi.call(caller, this.address, value, gasLimit, storageDepositLimit, bytes);
            if (raw.result.isErr) {
                throw new errors_js_1.ContractDispatchError(raw.result.err, raw);
            }
            const data = this.tryDecode(meta, raw.result.value.data);
            if (data.isErr) {
                throw new errors_js_1.ContractLangError(data.err, raw);
            }
            const bits = raw.result.value.flags.bits;
            return {
                data: data.value,
                raw,
                flags: (0, utils_js_1.toReturnFlags)(bits),
            };
        };
        callFn.meta = meta;
        return callFn;
    }
}
exports.QueryExecutor = QueryExecutor;
