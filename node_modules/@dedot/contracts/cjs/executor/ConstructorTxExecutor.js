"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorTxExecutor = void 0;
const utils_1 = require("@dedot/utils");
const index_js_1 = require("./abstract/index.js");
class ConstructorTxExecutor extends index_js_1.DeployerExecutor {
    doExecute(constructor) {
        const meta = this.findConstructorMeta(constructor);
        (0, utils_1.assert)(meta, `Constructor message not found: ${constructor}`);
        const callFn = (...params) => {
            const { args } = meta;
            (0, utils_1.assert)(params.length === args.length + 1, `Expected ${args.length + 1} arguments, got ${params.length}`);
            const txCallOptions = params[args.length];
            const { value = 0n, gasLimit, storageDepositLimit, salt = '0x' } = txCallOptions;
            (0, utils_1.assert)(gasLimit, 'Expected a gas limit in ConstructorTxOptions');
            (0, utils_1.assertFalse)((0, utils_1.isNull)(salt) || (0, utils_1.isUndefined)(salt), 'Expected a salt in ConstructorCallOptions');
            const formattedInputs = args.map((arg, index) => this.tryEncode(arg, params[index]));
            const bytes = (0, utils_1.u8aToHex)((0, utils_1.concatU8a)((0, utils_1.hexToU8a)(meta.selector), ...formattedInputs));
            if ((0, utils_1.isWasm)(this.code)) {
                return this.client.tx.contracts.instantiateWithCode(value, gasLimit, storageDepositLimit, this.code, bytes, salt);
            }
            else {
                return this.client.tx.contracts.instantiate(value, // prettier-end-here
                gasLimit, storageDepositLimit, this.code, bytes, salt);
            }
        };
        callFn.meta = meta;
        return callFn;
    }
}
exports.ConstructorTxExecutor = ConstructorTxExecutor;
