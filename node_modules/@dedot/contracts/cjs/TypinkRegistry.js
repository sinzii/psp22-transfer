"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypinkRegistry = void 0;
const codecs_1 = require("@dedot/codecs");
const $ = __importStar(require("@dedot/shape"));
const utils_1 = require("@dedot/utils");
const utils_js_1 = require("./utils.js");
class TypinkRegistry extends codecs_1.TypeRegistry {
    #metadata;
    constructor(metadata) {
        super((0, utils_js_1.extractContractTypes)(metadata));
        this.#metadata = metadata;
    }
    get metadata() {
        return this.#metadata;
    }
    decodeEvents(records, contract) {
        return records
            .filter(({ event }) => this.#isContractEmittedEvent(event, contract)) // prettier-end-here
            .map((record) => this.decodeEvent(record, contract));
    }
    decodeEvent(eventRecord, contract) {
        (0, utils_1.assert)(this.#isContractEmittedEvent(eventRecord.event, contract), 'Invalid ContractEmitted Event');
        const { version } = this.#metadata;
        switch (version) {
            case 5:
                return this.#decodeEventV5(eventRecord);
            case '4':
                return this.#decodeEventV4(eventRecord);
            default:
                throw new utils_1.DedotError('Unsupported metadata version!');
        }
    }
    #isContractEmittedEvent(event, contract) {
        const eventMatched = event.pallet === 'Contracts' &&
            typeof event.palletEvent === 'object' &&
            event.palletEvent.name === 'ContractEmitted';
        if (!eventMatched)
            return false;
        if (contract) {
            // @ts-ignore
            const emittedContract = event.palletEvent.data?.contract;
            if (emittedContract instanceof codecs_1.AccountId32) {
                return emittedContract.eq(contract);
            }
            else {
                return false;
            }
        }
        return true;
    }
    #decodeEventV4(eventRecord) {
        (0, utils_1.assert)(this.#metadata.version === '4', 'Invalid metadata version!');
        (0, utils_1.assert)(this.#isContractEmittedEvent(eventRecord.event), 'Invalid ContractEmitted Event');
        const data = (0, utils_1.hexToU8a)(eventRecord.event.palletEvent.data.data);
        const index = data.at(0);
        (0, utils_1.assert)(index !== undefined, 'Unable to decode event index!');
        const event = this.#metadata.spec.events[index];
        (0, utils_1.assert)(event, `Event index not found: ${index.toString()}`);
        return this.#tryDecodeEvent(event, data.subarray(1));
    }
    #decodeEventV5(eventRecord) {
        (0, utils_1.assert)(this.#metadata.version === 5, 'Invalid metadata version!');
        (0, utils_1.assert)(this.#isContractEmittedEvent(eventRecord.event), 'Invalid ContractEmitted Event');
        const data = (0, utils_1.hexToU8a)(eventRecord.event.palletEvent.data.data);
        const signatureTopic = eventRecord.topics.at(0);
        let eventMeta;
        if (signatureTopic) {
            eventMeta = this.#metadata.spec.events.find((one) => one.signature_topic === signatureTopic);
        }
        // TODO: Handle multiple anonymous events
        // If `event` does not exist, it means it's an anonymous event
        // that does not contain a signature topic in the metadata.
        if (!eventMeta) {
            const potentialEvents = this.#metadata.spec.events.filter((one) => !one.signature_topic && one.args.filter((arg) => arg.indexed).length === eventRecord.topics.length);
            (0, utils_1.assert)(potentialEvents.length === 1, 'Unable to determine event!');
            eventMeta = potentialEvents[0];
        }
        return this.#tryDecodeEvent(eventMeta, data);
    }
    #tryDecodeEvent(eventMeta, raw) {
        const { args, label } = eventMeta;
        const eventCodecFrame = args.reduce((frame, arg) => {
            const { label, type: { type }, } = arg;
            const $codec = this.findCodec(type);
            Object.assign(frame, { [(0, utils_1.stringCamelCase)(label)]: $codec });
            return frame;
        }, {});
        const $eventCodec = $.Struct(eventCodecFrame);
        const data = $eventCodec.decode(raw);
        const name = (0, utils_1.stringPascalCase)(label);
        return args.length ? { name, data } : { name };
    }
}
exports.TypinkRegistry = TypinkRegistry;
