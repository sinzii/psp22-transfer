import { deferred, noop } from '@dedot/utils';
/**
 * @name AsyncQueue
 * @description A queue to process async works in sequence,
 * only one work is processed at a time
 */
export class AsyncQueue {
    _works;
    _working;
    _currentWork;
    constructor() {
        this._works = [];
        this._working = false;
    }
    /**
     * Enqueue a work to be processed
     *
     * @param work
     */
    enqueue(work) {
        const defer = deferred();
        this._works.push({ work, defer });
        this.dequeue().catch(noop);
        return defer.promise;
    }
    /**
     * Clear the pending works queue
     */
    clear() {
        this._works.forEach(({ defer }) => {
            defer.reject(new Error('Queue cleaned'));
        });
        this._works = [];
    }
    /**
     * Cancel the current work & clear the queue
     */
    cancel() {
        this.cancelCurrentWork();
        this.clear();
    }
    /**
     * Cancel the current work if there is any work is going on
     */
    cancelCurrentWork() {
        if (!this._currentWork)
            return;
        this._currentWork.defer.reject(new Error('Work cancelled'));
        this._currentWork = undefined;
        this._working = false;
    }
    get size() {
        return this._works.length;
    }
    get isWorking() {
        return this._working;
    }
    async dequeue() {
        if (this._working)
            return;
        this._currentWork = this._works.shift();
        if (!this._currentWork)
            return;
        const { defer, work } = this._currentWork;
        try {
            this._working = true;
            const result = await work(this);
            this._working = false;
            defer.resolve(result);
        }
        catch (e) {
            this._working = false;
            defer.reject(e);
        }
        finally {
            this._currentWork = undefined;
            this.dequeue().catch(noop);
        }
    }
}
