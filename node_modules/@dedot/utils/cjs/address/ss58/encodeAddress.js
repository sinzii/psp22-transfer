"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAddress = exports.ALLOWED_DECODED_LENGTHS = exports.DEFAULT_SUBSTRATE_ADDRESS_PREFIX = void 0;
// Copyright 2017-2024 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34
const base_1 = require("@scure/base");
const concat_js_1 = require("../../concat.js");
const decodeAddress_js_1 = require("./decodeAddress.js");
const sshash_js_1 = require("./sshash.js");
exports.DEFAULT_SUBSTRATE_ADDRESS_PREFIX = 42;
exports.ALLOWED_DECODED_LENGTHS = [1, 2, 4, 8, 32, 33];
function encodeAddress(key, ss58Format = exports.DEFAULT_SUBSTRATE_ADDRESS_PREFIX) {
    // decode it, this means we can re-encode an address
    const u8a = (0, decodeAddress_js_1.decodeAddress)(key);
    if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {
        throw new Error('Out of range ss58Format specified');
    }
    else if (!exports.ALLOWED_DECODED_LENGTHS.includes(u8a.length)) {
        throw new Error(`Expected a valid key to convert, with length ${exports.ALLOWED_DECODED_LENGTHS.join(', ')}`);
    }
    const input = (0, concat_js_1.concatU8a)(ss58Format < 64
        ? Uint8Array.from([ss58Format])
        : Uint8Array.from([
            ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,
            (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6),
        ]), u8a);
    return base_1.base58.encode((0, concat_js_1.concatU8a)(input, (0, sshash_js_1.sshash)(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}
exports.encodeAddress = encodeAddress;
