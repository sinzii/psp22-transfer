"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeAddress = exports.ALLOWED_ENCODED_LENGTHS = void 0;
// Copyright 2017-2024 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6
const base_1 = require("@scure/base");
const is_js_1 = require("../../is.js");
const to_js_1 = require("../../to.js");
const checkAddressChecksum_js_1 = require("./checkAddressChecksum.js");
exports.ALLOWED_ENCODED_LENGTHS = [3, 4, 6, 10, 35, 36, 37, 38];
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
    if (!encoded) {
        throw new Error('Invalid empty address passed');
    }
    if ((0, is_js_1.isU8a)(encoded) || (0, is_js_1.isHex)(encoded)) {
        return (0, to_js_1.toU8a)(encoded);
    }
    try {
        const decoded = base_1.base58.decode(encoded);
        if (!exports.ALLOWED_ENCODED_LENGTHS.includes(decoded.length)) {
            throw new Error('Invalid decoded address length');
        }
        const [isValid, endPos, ss58Length, ss58Decoded] = (0, checkAddressChecksum_js_1.checkAddressChecksum)(decoded);
        if (!isValid && !ignoreChecksum) {
            throw new Error('Invalid decoded address checksum');
        }
        else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
            throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
        }
        return decoded.slice(ss58Length, endPos);
    }
    catch (error) {
        throw new Error(`Decoding ${encoded}: ${error.message}`);
    }
}
exports.decodeAddress = decodeAddress;
