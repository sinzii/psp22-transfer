import { isHex, isObject, isString, stringCamelCase } from '@dedot/utils';
import { DecodeBuffer, field, ShapeDecodeError, taggedUnion, variant, } from '../deshape.js';
export const Enum = (members, options) => {
    const tagKey = options?.tagKey || 'type';
    const valueKey = options?.valueKey || 'value';
    const enumMembers = {};
    Object.keys(members).forEach((keyName, keyIndex) => {
        if (members[keyName]) {
            const { index, value } = members[keyName];
            if (Number.isInteger(index)) {
                if (value) {
                    enumMembers[index] = variant(keyName, field(valueKey, value));
                }
                else {
                    enumMembers[index] = variant(keyName);
                }
            }
            else {
                enumMembers[keyIndex] = variant(keyName, field(valueKey, members[keyName]));
            }
        }
        else {
            enumMembers[keyIndex] = variant(keyName);
        }
    });
    const shaped = taggedUnion(tagKey, enumMembers);
    shaped.registerDecoder((input) => shouldDecodeSerdePlainValue(input, { tagKey }), (shape, input) => decodeSerdePlainValue(shape, input, { tagKey, valueKey }));
    // @ts-ignore
    return shaped;
};
// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return ((prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) &&
        !(Symbol.toStringTag in value) &&
        !(Symbol.iterator in value));
}
const shouldDecodeSerdePlainValue = (input, { tagKey }) => {
    return (isString(input) && !isHex(input)) || (isPlainObject(input) && !input[tagKey]);
};
const decodeSerdePlainValue = ($shape, input, { tagKey, valueKey }) => {
    const members = $shape.metadata[0].args[1];
    const variants = Object.values(members);
    if (isString(input)) {
        const targetVariant = variants.find((v) => v.tag === input || stringCamelCase(v.tag) === input);
        if (targetVariant) {
            const shapeMembers = targetVariant.shape.metadata[0].args;
            if (shapeMembers && shapeMembers.length === 0) {
                return { [tagKey]: targetVariant.tag };
            }
        }
    }
    else if (isObject(input)) {
        const targetVariant = variants.find((v) => !!input[v.tag] || !!input[stringCamelCase(v.tag)]);
        if (targetVariant) {
            // TODO docs!
            const targetShape = targetVariant.shape.metadata[0].args[0].metadata[0].args[1];
            const value = input[targetVariant.tag] || input[stringCamelCase(targetVariant.tag)];
            return {
                [tagKey]: targetVariant.tag,
                [valueKey]: targetShape.tryDecode(value),
            };
        }
    }
    throw new ShapeDecodeError($shape, new DecodeBuffer(new Uint8Array()), `Cannot decode plain serde input: ${JSON.stringify(input)}`);
};
