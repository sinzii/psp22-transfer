"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enum = void 0;
const utils_1 = require("@dedot/utils");
const deshape_js_1 = require("../deshape.js");
const Enum = (members, options) => {
    const tagKey = options?.tagKey || 'type';
    const valueKey = options?.valueKey || 'value';
    const enumMembers = {};
    Object.keys(members).forEach((keyName, keyIndex) => {
        if (members[keyName]) {
            const { index, value } = members[keyName];
            if (Number.isInteger(index)) {
                if (value) {
                    enumMembers[index] = (0, deshape_js_1.variant)(keyName, (0, deshape_js_1.field)(valueKey, value));
                }
                else {
                    enumMembers[index] = (0, deshape_js_1.variant)(keyName);
                }
            }
            else {
                enumMembers[keyIndex] = (0, deshape_js_1.variant)(keyName, (0, deshape_js_1.field)(valueKey, members[keyName]));
            }
        }
        else {
            enumMembers[keyIndex] = (0, deshape_js_1.variant)(keyName);
        }
    });
    const shaped = (0, deshape_js_1.taggedUnion)(tagKey, enumMembers);
    shaped.registerDecoder((input) => shouldDecodeSerdePlainValue(input, { tagKey }), (shape, input) => decodeSerdePlainValue(shape, input, { tagKey, valueKey }));
    // @ts-ignore
    return shaped;
};
exports.Enum = Enum;
// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return ((prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) &&
        !(Symbol.toStringTag in value) &&
        !(Symbol.iterator in value));
}
const shouldDecodeSerdePlainValue = (input, { tagKey }) => {
    return ((0, utils_1.isString)(input) && !(0, utils_1.isHex)(input)) || (isPlainObject(input) && !input[tagKey]);
};
const decodeSerdePlainValue = ($shape, input, { tagKey, valueKey }) => {
    const members = $shape.metadata[0].args[1];
    const variants = Object.values(members);
    if ((0, utils_1.isString)(input)) {
        const targetVariant = variants.find((v) => v.tag === input || (0, utils_1.stringCamelCase)(v.tag) === input);
        if (targetVariant) {
            const shapeMembers = targetVariant.shape.metadata[0].args;
            if (shapeMembers && shapeMembers.length === 0) {
                return { [tagKey]: targetVariant.tag };
            }
        }
    }
    else if ((0, utils_1.isObject)(input)) {
        const targetVariant = variants.find((v) => !!input[v.tag] || !!input[(0, utils_1.stringCamelCase)(v.tag)]);
        if (targetVariant) {
            // TODO docs!
            const targetShape = targetVariant.shape.metadata[0].args[0].metadata[0].args[1];
            const value = input[targetVariant.tag] || input[(0, utils_1.stringCamelCase)(targetVariant.tag)];
            return {
                [tagKey]: targetVariant.tag,
                [valueKey]: targetShape.tryDecode(value),
            };
        }
    }
    throw new deshape_js_1.ShapeDecodeError($shape, new deshape_js_1.DecodeBuffer(new Uint8Array()), `Cannot decode plain serde input: ${JSON.stringify(input)}`);
};
