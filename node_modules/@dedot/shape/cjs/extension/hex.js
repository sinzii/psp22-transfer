"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefixedHex = exports.FixedHex = void 0;
const utils_1 = require("@dedot/utils");
const deshape_js_1 = require("../deshape.js");
const compact_js_1 = require("./compact.js");
const createShape_js_1 = require("./createShape.js");
const HEX_PREFIX = '0x';
function FixedHex(lengthInBytes) {
    const shaped = (0, deshape_js_1.hex)((0, deshape_js_1.sizedUint8Array)(lengthInBytes));
    const originalSubDecode = shaped.subDecode.bind(shaped);
    shaped.subDecode = function (buffer) {
        const decoded = originalSubDecode(buffer);
        return decoded.startsWith(HEX_PREFIX) ? decoded : `${HEX_PREFIX}${decoded}`;
    };
    return shaped;
}
exports.FixedHex = FixedHex;
exports.PrefixedHex = (0, createShape_js_1.createShape)({
    metadata: (0, deshape_js_1.metadata)('$.PrefixedHex'),
    staticSize: compact_js_1.compactU32.staticSize,
    subEncode(buffer, value) {
        const u8a = (0, utils_1.hexToU8a)(value);
        compact_js_1.compactU32.subEncode(buffer, u8a.length);
        buffer.insertArray(u8a);
    },
    subDecode(buffer) {
        const length = compact_js_1.compactU32.subDecode(buffer);
        const value = buffer.array.subarray(buffer.index, buffer.index + length);
        buffer.index += length;
        return (0, utils_1.u8aToHex)(value);
    },
});
